// Code generated by protoc-gen-go. DO NOT EDIT.
// source: flyteidl/core/dynamic_job.proto

package core // import "github.com/lyft/flyteidl/gen/pb-go/flyteidl/core"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Describes a set of tasks to execute and how the final outputs are produced.
type DynamicJobSpec struct {
	// A collection of nodes to execute.
	Nodes []*DynamicNode `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes,omitempty"`
	// An absolute number of the minimum number of successful completions of subtasks. As soon as this criteria is met,
	// the dynamic job will be marked as successful and outputs will be computed.
	MinSuccesses int64 `protobuf:"varint,2,opt,name=min_successes,json=minSuccesses,proto3" json:"min_successes,omitempty"`
	// Describes how to bind the final output of the dynamic job from the outputs of executed nodes. The referenced ids
	// in bindings should have the generated id for the subtask.
	Outputs []*Binding `protobuf:"bytes,3,rep,name=outputs,proto3" json:"outputs,omitempty"`
	// [Optional] A complete list of task specs referenced in nodes.
	Tasks                []*TaskTemplate `protobuf:"bytes,4,rep,name=tasks,proto3" json:"tasks,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *DynamicJobSpec) Reset()         { *m = DynamicJobSpec{} }
func (m *DynamicJobSpec) String() string { return proto.CompactTextString(m) }
func (*DynamicJobSpec) ProtoMessage()    {}
func (*DynamicJobSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_dynamic_job_d3ca951f44bef525, []int{0}
}
func (m *DynamicJobSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DynamicJobSpec.Unmarshal(m, b)
}
func (m *DynamicJobSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DynamicJobSpec.Marshal(b, m, deterministic)
}
func (dst *DynamicJobSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DynamicJobSpec.Merge(dst, src)
}
func (m *DynamicJobSpec) XXX_Size() int {
	return xxx_messageInfo_DynamicJobSpec.Size(m)
}
func (m *DynamicJobSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_DynamicJobSpec.DiscardUnknown(m)
}

var xxx_messageInfo_DynamicJobSpec proto.InternalMessageInfo

func (m *DynamicJobSpec) GetNodes() []*DynamicNode {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *DynamicJobSpec) GetMinSuccesses() int64 {
	if m != nil {
		return m.MinSuccesses
	}
	return 0
}

func (m *DynamicJobSpec) GetOutputs() []*Binding {
	if m != nil {
		return m.Outputs
	}
	return nil
}

func (m *DynamicJobSpec) GetTasks() []*TaskTemplate {
	if m != nil {
		return m.Tasks
	}
	return nil
}

// Describes a single node to execute that can potentially produce more tasks to run.
type DynamicNode struct {
	// A unique identifier prefix within the document. This is used to generate unique ids for each of the tasks in
	// target. The generated ids have this format: <generate_id>:<n> where n starts with 0 and monotonically increases.
	// e.g. if generate_id is set to "my_array_job", the first task in the array job will have the id "my_array_job:0",
	// then "my_array_job:1"... etc.
	GenerateId string `protobuf:"bytes,1,opt,name=generate_id,json=generateId,proto3" json:"generate_id,omitempty"`
	// Extra metadata about the node.
	Metadata *NodeMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// The executable target of the node. The task custom field will contain one of:
	// HiveQueryCollection (When task.type is set to HIVE_QUERIES) or ArrayJob (When task.type is set to either
	// CONTAINER or SWARM).
	//
	// Types that are valid to be assigned to Target:
	//	*DynamicNode_TaskRef
	Target               isDynamicNode_Target `protobuf_oneof:"target"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *DynamicNode) Reset()         { *m = DynamicNode{} }
func (m *DynamicNode) String() string { return proto.CompactTextString(m) }
func (*DynamicNode) ProtoMessage()    {}
func (*DynamicNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_dynamic_job_d3ca951f44bef525, []int{1}
}
func (m *DynamicNode) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DynamicNode.Unmarshal(m, b)
}
func (m *DynamicNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DynamicNode.Marshal(b, m, deterministic)
}
func (dst *DynamicNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DynamicNode.Merge(dst, src)
}
func (m *DynamicNode) XXX_Size() int {
	return xxx_messageInfo_DynamicNode.Size(m)
}
func (m *DynamicNode) XXX_DiscardUnknown() {
	xxx_messageInfo_DynamicNode.DiscardUnknown(m)
}

var xxx_messageInfo_DynamicNode proto.InternalMessageInfo

func (m *DynamicNode) GetGenerateId() string {
	if m != nil {
		return m.GenerateId
	}
	return ""
}

func (m *DynamicNode) GetMetadata() *NodeMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type isDynamicNode_Target interface {
	isDynamicNode_Target()
}

type DynamicNode_TaskRef struct {
	TaskRef *TaskNode `protobuf:"bytes,3,opt,name=task_ref,json=taskRef,proto3,oneof"`
}

func (*DynamicNode_TaskRef) isDynamicNode_Target() {}

func (m *DynamicNode) GetTarget() isDynamicNode_Target {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *DynamicNode) GetTaskRef() *TaskNode {
	if x, ok := m.GetTarget().(*DynamicNode_TaskRef); ok {
		return x.TaskRef
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DynamicNode) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DynamicNode_OneofMarshaler, _DynamicNode_OneofUnmarshaler, _DynamicNode_OneofSizer, []interface{}{
		(*DynamicNode_TaskRef)(nil),
	}
}

func _DynamicNode_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DynamicNode)
	// target
	switch x := m.Target.(type) {
	case *DynamicNode_TaskRef:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TaskRef); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("DynamicNode.Target has unexpected type %T", x)
	}
	return nil
}

func _DynamicNode_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DynamicNode)
	switch tag {
	case 3: // target.task_ref
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TaskNode)
		err := b.DecodeMessage(msg)
		m.Target = &DynamicNode_TaskRef{msg}
		return true, err
	default:
		return false, nil
	}
}

func _DynamicNode_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DynamicNode)
	// target
	switch x := m.Target.(type) {
	case *DynamicNode_TaskRef:
		s := proto.Size(x.TaskRef)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*DynamicJobSpec)(nil), "flyteidl.core.DynamicJobSpec")
	proto.RegisterType((*DynamicNode)(nil), "flyteidl.core.DynamicNode")
}

func init() {
	proto.RegisterFile("flyteidl/core/dynamic_job.proto", fileDescriptor_dynamic_job_d3ca951f44bef525)
}

var fileDescriptor_dynamic_job_d3ca951f44bef525 = []byte{
	// 345 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0xd1, 0xbf, 0x4e, 0xfb, 0x30,
	0x10, 0x07, 0xf0, 0x5f, 0x7e, 0xa1, 0x7f, 0x70, 0x29, 0x83, 0x07, 0x08, 0x05, 0xa9, 0x55, 0x59,
	0xba, 0x90, 0x94, 0x82, 0xc4, 0x5e, 0x31, 0x00, 0x12, 0x0c, 0x6e, 0x27, 0x96, 0xc8, 0x89, 0x2f,
	0xc1, 0x34, 0xb1, 0x23, 0xdb, 0x51, 0xd5, 0x27, 0xe2, 0x65, 0x78, 0x28, 0x94, 0xa4, 0xa9, 0x48,
	0xe9, 0xea, 0xfb, 0xdc, 0xdd, 0xd7, 0x3a, 0x34, 0x8c, 0x92, 0x8d, 0x01, 0xce, 0x12, 0x2f, 0x94,
	0x0a, 0x3c, 0xb6, 0x11, 0x34, 0xe5, 0xa1, 0xff, 0x29, 0x03, 0x37, 0x53, 0xd2, 0x48, 0xdc, 0xaf,
	0x81, 0x5b, 0x80, 0xc1, 0x45, 0xd3, 0x1b, 0xaa, 0x57, 0xba, 0x92, 0x83, 0xab, 0x66, 0x69, 0x2d,
	0xd5, 0x2a, 0x4a, 0xe4, 0xfa, 0x70, 0x35, 0xe1, 0x06, 0x14, 0x4d, 0xb6, 0xbd, 0xe3, 0x6f, 0x0b,
	0x9d, 0x3e, 0x56, 0xbb, 0x5f, 0x64, 0xb0, 0xc8, 0x20, 0xc4, 0x53, 0xd4, 0x12, 0x92, 0x81, 0x76,
	0xac, 0x91, 0x3d, 0xe9, 0xcd, 0x06, 0x6e, 0x23, 0x88, 0xbb, 0xd5, 0x6f, 0x92, 0x01, 0xa9, 0x20,
	0xbe, 0x46, 0xfd, 0x94, 0x0b, 0x5f, 0xe7, 0x61, 0x08, 0x5a, 0x83, 0x76, 0xfe, 0x8f, 0xac, 0x89,
	0x4d, 0x4e, 0x52, 0x2e, 0x16, 0xf5, 0x1b, 0x9e, 0xa2, 0x8e, 0xcc, 0x4d, 0x96, 0x1b, 0xed, 0xd8,
	0xe5, 0xe0, 0xb3, 0xbd, 0xc1, 0x73, 0x2e, 0x18, 0x17, 0x31, 0xa9, 0x19, 0xbe, 0x45, 0xad, 0xf2,
	0x9b, 0xce, 0x51, 0xe9, 0x2f, 0xf7, 0xfc, 0x92, 0xea, 0xd5, 0x12, 0xd2, 0x2c, 0xa1, 0x06, 0x48,
	0x25, 0xc7, 0x5f, 0x16, 0xea, 0xfd, 0x0a, 0x88, 0x87, 0xa8, 0x17, 0x83, 0x00, 0x45, 0x0d, 0xf8,
	0x9c, 0x39, 0xd6, 0xc8, 0x9a, 0x1c, 0x13, 0x54, 0x3f, 0x3d, 0x33, 0xfc, 0x80, 0xba, 0x29, 0x18,
	0xca, 0xa8, 0xa1, 0x65, 0xea, 0xbf, 0x6b, 0x8a, 0x39, 0xaf, 0x5b, 0x42, 0x76, 0x18, 0xdf, 0xa3,
	0x6e, 0xb1, 0xd2, 0x57, 0x10, 0x39, 0x76, 0xd9, 0x78, 0x7e, 0x20, 0x5f, 0xd1, 0xfc, 0xf4, 0x8f,
	0x74, 0x0a, 0x4a, 0x20, 0x9a, 0x77, 0x51, 0xdb, 0x50, 0x15, 0x83, 0x99, 0xcf, 0xde, 0xa7, 0x31,
	0x37, 0x1f, 0x79, 0xe0, 0x86, 0x32, 0xf5, 0x92, 0x4d, 0x64, 0xbc, 0xdd, 0xa1, 0x62, 0x10, 0x5e,
	0x16, 0xdc, 0xc4, 0xd2, 0x6b, 0xdc, 0x2e, 0x68, 0x97, 0x37, 0xbb, 0xfb, 0x09, 0x00, 0x00, 0xff,
	0xff, 0x8a, 0x6d, 0x3b, 0x68, 0x3c, 0x02, 0x00, 0x00,
}
