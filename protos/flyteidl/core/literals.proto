syntax = "proto3";

package flyteidl.core;

option go_package = "github.com/lyft/flyteidl/gen/pb-go/flyteidl/core";

import "flyteidl/core/identifier.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/struct.proto";
import "flyteidl/core/types.proto";
import "flyteidl/core/condition.proto";
import "flyteidl/core/tasks.proto";
import "flyteidl/core/primitives.proto";

// Used to denote a nil/null/None assignment to a scalar value. The underlying LiteralType for Void is intentionally
// undefined since it can be assigned to a scalar of any LiteralType.
message Void {
}

// Refers to an offloaded set of files. It encapsulates the type of the store and a unique uri for where the data is.
// There are no restrictions on how the uri is formatted since it will depend on how to interact with the store.
message Blob {
    BlobMetadata metadata = 1;
    string uri = 3;
}

message BlobMetadata {
    BlobType type = 1;
}

// A simple byte array with a tag to help different parts of the system communicate about what is in the byte array.
// It's strongly advisable that consumers of this type define a unique tag and validate the tag before parsing the data.
message Binary {
    bytes value = 1;
    string tag = 2;
}

// A strongly typed schema that defines the interface of data retrieved from the underlying storage medium.
message Schema {
    string uri = 1;
    SchemaType type = 3;
}

message Scalar {
    oneof value {
        Primitive primitive = 1;
        Blob blob = 2;
        Binary binary = 3;
        Schema schema = 4;
        Void none_type = 5;
        Error error = 6;
        google.protobuf.Struct generic = 7;
        Closure closure = 8;
    }
}

// Represents a node closure that contain all required information to execute.
message Closure {
    // A node to execute. All inputs of the node must be statically bound in node input bindings. Dynamic bindings
    // is not yet supported.
    Node node = 1;

    // [Optional] List of task specs directly or indirectly referenced in node. This list will take precedence over
    // other task specs found in the environment (e.g. in an enclosing workflow) when resolving task references.
    repeated TaskTemplate tasks = 2;

    // [Optional] List of workflow specs directly or indirectly referenced in node. This list will take precedence over
    // other workflow specs found in the environment (e.g. in an enclosing workflow) when resolving workflows references.
    repeated WorkflowTemplate sub_workflows = 3;
}

// A simple value. This supports any level of nesting (e.g. array of array of array of Blobs) as well as simple primitives.
message Literal {
    oneof value {
        // A simple value.
        Scalar scalar = 1;

        // A collection of literals to allow nesting.
        LiteralCollection collection = 2;

        // A map of strings to literals.
        LiteralMap map = 3;
    }
}

// A collection of literals. This is a workaround since oneofs in proto messages cannot contain a repeated field.
message LiteralCollection {
    repeated Literal literals = 1;
}

// A map of literals. This is a workaround since oneofs in proto messages cannot contain a repeated field.
message LiteralMap {
    map<string, Literal> literals = 1;
}

// A collection of BindingData items.
message BindingDataCollection {
    repeated BindingData bindings = 1;
}

// A map of BindingData items.
message BindingDataMap {
    map<string, BindingData> bindings = 1;
}

// Specifies either a simple value or a reference to another output.
message BindingData {
    oneof value {
        // A simple scalar value.
        Scalar scalar = 1;

        // A collection of binding data. This allows nesting of binding data to any number
        // of levels.
        BindingDataCollection collection = 2;

        // References an output promised by another node.
        OutputReference promise = 3;

        // A map of bindings. The key is always a string.
        BindingDataMap map = 4;

        Closure closure = 5;
    }
}

// An input/output binding of a variable to either static value or a node output.
message Binding {
    // Variable name must match an input/output variable of the node.
    string var = 1;

    // Data to use to bind this variable.
    BindingData binding = 2;
}

// Defines a condition and the execution unit that should be executed if the condition is satisfied.
message IfBlock {
    core.BooleanExpression condition = 1;
    Node then_node = 2;
}

// Defines a series of if/else blocks. The first branch whose condition evaluates to true is the one to execute.
// If no conditions were satisfied, the else_node or the error will execute.
message IfElseBlock {
    //+required. First condition to evaluate.
    IfBlock case = 1;

    //+optional. Additional branches to evaluate.
    repeated IfBlock other = 2;

    //+required.
    oneof default {
        // The node to execute in case none of the branches were taken.
        Node else_node = 3;

        // An error to throw in case none of the branches were taken.
        Error error = 4;
    }
}

// BranchNode is a special node that alter the flow of the workflow graph. It allows the control flow to branch at
// runtime based on a series of conditions that get evaluated on various parameters (e.g. inputs, primtives).
message BranchNode {
    //+required
    IfElseBlock if_else = 1;
}

// A specialized node type that expects a Closure as an additional input called "input_closure". Other inputs bound
// will be passed down to the closure if it expects any, otherwise additional inputs will be ignored.
message ClosureNode {
    // The closure type to expect to be bound to "input_closure" input for this node. ClosureType interface must be
    // populated if inputs/outputs are expected to be passed to and consumed from, respectively, the executed closure.
    ClosureType closure_type = 1;
}

// Refers to the task that the Node is to execute.
message TaskNode {
    oneof reference {
        // A globally unique identifier for the task.
        Identifier reference_id = 1;
    }
}

// Refers to a the workflow the node is to execute.
message WorkflowNode {
    oneof reference {
        // A globally unique identifier for the launch plan.
        Identifier launchplan_ref = 1;

        // Reference to a subworkflow, that should be defined with the compiler context
        Identifier sub_workflow_ref = 2;
    }
}

// Defines extra information about the Node.
message NodeMetadata {
    // A friendly name for the Node
    string name = 1;

    // The overall timeout of a task.
    google.protobuf.Duration timeout = 4;

    // Number of retries per task.
    RetryStrategy retries = 5;
}

// Links a variable to an alias.
message Alias {
    // Must match one of the output variable names on a node.
    string var = 1;

    // A workflow-level unique alias that downstream nodes can refer to in their input.
    string alias = 2;
}

// A Workflow graph Node. One unit of execution in the graph. Each node can be linked to a Task, a Workflow or a branch
// node.
message Node {
    // A workflow-level unique identifier that identifies this node in the workflow. "inputs" and "outputs" are reserved
    // node ids that cannot be used by other nodes.
    string id = 1;

    // Extra metadata about the node.
    NodeMetadata metadata = 2;

    // Specifies how to bind the underlying interface's inputs. All required inputs specified in the underlying interface
    // must be fullfilled.
    repeated Binding inputs = 3;

    //+optional Specifies execution depdendency for this node ensuring it will only get scheduled to run after all its
    // upstream nodes have completed. This node will have an implicit depdendency on any node that appears in inputs
    // field.
    repeated string upstream_node_ids = 4;

    //+optional. A node can define aliases for a subset of its outputs. This is particularly useful if different nodes
    // need to conform to the same interface (e.g. all branches in a branch node). Downstream nodes must refer to this
    // nodes outputs using the alias if one's specified.
    repeated Alias output_aliases = 5;

    // Information about the target to execute in this node.
    oneof target {
        // Information about the Task to execute in this node.
        TaskNode task_node = 6;

        // Information about the Workflow to execute in this mode.
        WorkflowNode workflow_node = 7;

        // Information about the branch node to evaluate in this node.
        BranchNode branch_node = 8;

        ClosureNode closure_node = 9;
    }
}

// Metadata for the entire workflow.
// To be used in the future.
message WorkflowMetadata {
}

// Flyte Workflow Structure that encapsulates task, branch and subworkflow nodes to form a statically analyzable,
// directed acyclic graph.
message WorkflowTemplate {
    // This is an autogenerated id by the system. The id is globally unique across the system.
    Identifier id = 1;

    // Extra metadata about the workflow.
    WorkflowMetadata metadata = 2;

    // Defines a strongly typed interface for the Workflow. This can include some optional parameters.
    TypedInterface interface = 3;

    // A list of nodes. In addition, "globals" is a special reserved node id that can be used to consume workflow inputs.
    repeated Node nodes = 4;

    // A list of output bindings that specify how to construct workflow outputs. Bindings can pull node outputs or
    // specify literals. All workflow outputs specified in the interface field must be bound in order for the workflow
    // to be validated. A workflow has an implicit dependency on all of its nodes to execute successfully in order to
    // bind final outputs.
    // Most of these outputs will be Binding's with a BindingData of type OutputReference.  That is, your workflow can
    // just have an output of some constant (`Output(5)`), but usually, the workflow will be pulling
    // outputs from the output of a task.
    repeated Binding outputs = 5;

    //+optional A catch-all node. This node is executed whenever the execution engine determines the workflow has failed.
    // The interface of this node must match the Workflow interface with an additional input named "error" of type
    // pb.lyft.flyte.core.Error.
    Node failure_node = 6;
}
