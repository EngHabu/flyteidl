// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: flyteidl/core/literals.proto

package core

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"strings"
	"time"
	"unicode/utf8"

	"github.com/golang/protobuf/ptypes"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = ptypes.DynamicAny{}
)

// Validate checks the field values on Void with the rules defined in the proto
// definition for this message. If any rules are violated, an error is returned.
func (m *Void) Validate() error {
	if m == nil {
		return nil
	}

	return nil
}

// VoidValidationError is the validation error returned by Void.Validate if the
// designated constraints aren't met.
type VoidValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VoidValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VoidValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VoidValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VoidValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VoidValidationError) ErrorName() string { return "VoidValidationError" }

// Error satisfies the builtin error interface
func (e VoidValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVoid.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VoidValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VoidValidationError{}

// Validate checks the field values on Blob with the rules defined in the proto
// definition for this message. If any rules are violated, an error is returned.
func (m *Blob) Validate() error {
	if m == nil {
		return nil
	}

	if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlobValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Uri

	return nil
}

// BlobValidationError is the validation error returned by Blob.Validate if the
// designated constraints aren't met.
type BlobValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BlobValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BlobValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BlobValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BlobValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BlobValidationError) ErrorName() string { return "BlobValidationError" }

// Error satisfies the builtin error interface
func (e BlobValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlob.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BlobValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BlobValidationError{}

// Validate checks the field values on BlobMetadata with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *BlobMetadata) Validate() error {
	if m == nil {
		return nil
	}

	if v, ok := interface{}(m.GetType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlobMetadataValidationError{
				field:  "Type",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	return nil
}

// BlobMetadataValidationError is the validation error returned by
// BlobMetadata.Validate if the designated constraints aren't met.
type BlobMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BlobMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BlobMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BlobMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BlobMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BlobMetadataValidationError) ErrorName() string { return "BlobMetadataValidationError" }

// Error satisfies the builtin error interface
func (e BlobMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlobMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BlobMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BlobMetadataValidationError{}

// Validate checks the field values on Binary with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *Binary) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Value

	// no validation rules for Tag

	return nil
}

// BinaryValidationError is the validation error returned by Binary.Validate if
// the designated constraints aren't met.
type BinaryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BinaryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BinaryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BinaryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BinaryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BinaryValidationError) ErrorName() string { return "BinaryValidationError" }

// Error satisfies the builtin error interface
func (e BinaryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBinary.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BinaryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BinaryValidationError{}

// Validate checks the field values on Schema with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *Schema) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Uri

	if v, ok := interface{}(m.GetType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SchemaValidationError{
				field:  "Type",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	return nil
}

// SchemaValidationError is the validation error returned by Schema.Validate if
// the designated constraints aren't met.
type SchemaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SchemaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SchemaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SchemaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SchemaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SchemaValidationError) ErrorName() string { return "SchemaValidationError" }

// Error satisfies the builtin error interface
func (e SchemaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSchema.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SchemaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SchemaValidationError{}

// Validate checks the field values on Scalar with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *Scalar) Validate() error {
	if m == nil {
		return nil
	}

	switch m.Value.(type) {

	case *Scalar_Primitive:

		if v, ok := interface{}(m.GetPrimitive()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ScalarValidationError{
					field:  "Primitive",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Scalar_Blob:

		if v, ok := interface{}(m.GetBlob()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ScalarValidationError{
					field:  "Blob",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Scalar_Binary:

		if v, ok := interface{}(m.GetBinary()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ScalarValidationError{
					field:  "Binary",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Scalar_Schema:

		if v, ok := interface{}(m.GetSchema()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ScalarValidationError{
					field:  "Schema",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Scalar_NoneType:

		if v, ok := interface{}(m.GetNoneType()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ScalarValidationError{
					field:  "NoneType",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Scalar_Error:

		if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ScalarValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Scalar_Generic:

		if v, ok := interface{}(m.GetGeneric()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ScalarValidationError{
					field:  "Generic",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// ScalarValidationError is the validation error returned by Scalar.Validate if
// the designated constraints aren't met.
type ScalarValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScalarValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScalarValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScalarValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScalarValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScalarValidationError) ErrorName() string { return "ScalarValidationError" }

// Error satisfies the builtin error interface
func (e ScalarValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScalar.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScalarValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScalarValidationError{}

// Validate checks the field values on Closure with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *Closure) Validate() error {
	if m == nil {
		return nil
	}

	if v, ok := interface{}(m.GetNode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClosureValidationError{
				field:  "Node",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetTasks() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClosureValidationError{
					field:  fmt.Sprintf("Tasks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSubWorkflows() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClosureValidationError{
					field:  fmt.Sprintf("SubWorkflows[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// ClosureValidationError is the validation error returned by Closure.Validate
// if the designated constraints aren't met.
type ClosureValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClosureValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClosureValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClosureValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClosureValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClosureValidationError) ErrorName() string { return "ClosureValidationError" }

// Error satisfies the builtin error interface
func (e ClosureValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClosure.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClosureValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClosureValidationError{}

// Validate checks the field values on Literal with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *Literal) Validate() error {
	if m == nil {
		return nil
	}

	switch m.Value.(type) {

	case *Literal_Scalar:

		if v, ok := interface{}(m.GetScalar()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LiteralValidationError{
					field:  "Scalar",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Literal_Collection:

		if v, ok := interface{}(m.GetCollection()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LiteralValidationError{
					field:  "Collection",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Literal_Map:

		if v, ok := interface{}(m.GetMap()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LiteralValidationError{
					field:  "Map",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Literal_Closure:

		if v, ok := interface{}(m.GetClosure()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LiteralValidationError{
					field:  "Closure",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// LiteralValidationError is the validation error returned by Literal.Validate
// if the designated constraints aren't met.
type LiteralValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LiteralValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LiteralValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LiteralValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LiteralValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LiteralValidationError) ErrorName() string { return "LiteralValidationError" }

// Error satisfies the builtin error interface
func (e LiteralValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLiteral.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LiteralValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LiteralValidationError{}

// Validate checks the field values on LiteralCollection with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned.
func (m *LiteralCollection) Validate() error {
	if m == nil {
		return nil
	}

	for idx, item := range m.GetLiterals() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LiteralCollectionValidationError{
					field:  fmt.Sprintf("Literals[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// LiteralCollectionValidationError is the validation error returned by
// LiteralCollection.Validate if the designated constraints aren't met.
type LiteralCollectionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LiteralCollectionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LiteralCollectionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LiteralCollectionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LiteralCollectionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LiteralCollectionValidationError) ErrorName() string {
	return "LiteralCollectionValidationError"
}

// Error satisfies the builtin error interface
func (e LiteralCollectionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLiteralCollection.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LiteralCollectionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LiteralCollectionValidationError{}

// Validate checks the field values on LiteralMap with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *LiteralMap) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Literals

	return nil
}

// LiteralMapValidationError is the validation error returned by
// LiteralMap.Validate if the designated constraints aren't met.
type LiteralMapValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LiteralMapValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LiteralMapValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LiteralMapValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LiteralMapValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LiteralMapValidationError) ErrorName() string { return "LiteralMapValidationError" }

// Error satisfies the builtin error interface
func (e LiteralMapValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLiteralMap.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LiteralMapValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LiteralMapValidationError{}

// Validate checks the field values on BindingDataCollection with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *BindingDataCollection) Validate() error {
	if m == nil {
		return nil
	}

	for idx, item := range m.GetBindings() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BindingDataCollectionValidationError{
					field:  fmt.Sprintf("Bindings[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// BindingDataCollectionValidationError is the validation error returned by
// BindingDataCollection.Validate if the designated constraints aren't met.
type BindingDataCollectionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BindingDataCollectionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BindingDataCollectionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BindingDataCollectionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BindingDataCollectionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BindingDataCollectionValidationError) ErrorName() string {
	return "BindingDataCollectionValidationError"
}

// Error satisfies the builtin error interface
func (e BindingDataCollectionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBindingDataCollection.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BindingDataCollectionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BindingDataCollectionValidationError{}

// Validate checks the field values on BindingDataMap with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *BindingDataMap) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Bindings

	return nil
}

// BindingDataMapValidationError is the validation error returned by
// BindingDataMap.Validate if the designated constraints aren't met.
type BindingDataMapValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BindingDataMapValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BindingDataMapValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BindingDataMapValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BindingDataMapValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BindingDataMapValidationError) ErrorName() string { return "BindingDataMapValidationError" }

// Error satisfies the builtin error interface
func (e BindingDataMapValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBindingDataMap.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BindingDataMapValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BindingDataMapValidationError{}

// Validate checks the field values on BindingData with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *BindingData) Validate() error {
	if m == nil {
		return nil
	}

	switch m.Value.(type) {

	case *BindingData_Scalar:

		if v, ok := interface{}(m.GetScalar()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BindingDataValidationError{
					field:  "Scalar",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *BindingData_Collection:

		if v, ok := interface{}(m.GetCollection()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BindingDataValidationError{
					field:  "Collection",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *BindingData_Promise:

		if v, ok := interface{}(m.GetPromise()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BindingDataValidationError{
					field:  "Promise",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *BindingData_Map:

		if v, ok := interface{}(m.GetMap()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BindingDataValidationError{
					field:  "Map",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *BindingData_Closure:

		if v, ok := interface{}(m.GetClosure()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BindingDataValidationError{
					field:  "Closure",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// BindingDataValidationError is the validation error returned by
// BindingData.Validate if the designated constraints aren't met.
type BindingDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BindingDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BindingDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BindingDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BindingDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BindingDataValidationError) ErrorName() string { return "BindingDataValidationError" }

// Error satisfies the builtin error interface
func (e BindingDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBindingData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BindingDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BindingDataValidationError{}

// Validate checks the field values on Binding with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *Binding) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Var

	if v, ok := interface{}(m.GetBinding()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BindingValidationError{
				field:  "Binding",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	return nil
}

// BindingValidationError is the validation error returned by Binding.Validate
// if the designated constraints aren't met.
type BindingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BindingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BindingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BindingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BindingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BindingValidationError) ErrorName() string { return "BindingValidationError" }

// Error satisfies the builtin error interface
func (e BindingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBinding.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BindingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BindingValidationError{}

// Validate checks the field values on IfBlock with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *IfBlock) Validate() error {
	if m == nil {
		return nil
	}

	if v, ok := interface{}(m.GetCondition()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IfBlockValidationError{
				field:  "Condition",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetThenNode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IfBlockValidationError{
				field:  "ThenNode",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	return nil
}

// IfBlockValidationError is the validation error returned by IfBlock.Validate
// if the designated constraints aren't met.
type IfBlockValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IfBlockValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IfBlockValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IfBlockValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IfBlockValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IfBlockValidationError) ErrorName() string { return "IfBlockValidationError" }

// Error satisfies the builtin error interface
func (e IfBlockValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIfBlock.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IfBlockValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IfBlockValidationError{}

// Validate checks the field values on IfElseBlock with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *IfElseBlock) Validate() error {
	if m == nil {
		return nil
	}

	if v, ok := interface{}(m.GetCase()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IfElseBlockValidationError{
				field:  "Case",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetOther() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IfElseBlockValidationError{
					field:  fmt.Sprintf("Other[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	switch m.Default.(type) {

	case *IfElseBlock_ElseNode:

		if v, ok := interface{}(m.GetElseNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IfElseBlockValidationError{
					field:  "ElseNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *IfElseBlock_Error:

		if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IfElseBlockValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// IfElseBlockValidationError is the validation error returned by
// IfElseBlock.Validate if the designated constraints aren't met.
type IfElseBlockValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IfElseBlockValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IfElseBlockValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IfElseBlockValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IfElseBlockValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IfElseBlockValidationError) ErrorName() string { return "IfElseBlockValidationError" }

// Error satisfies the builtin error interface
func (e IfElseBlockValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIfElseBlock.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IfElseBlockValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IfElseBlockValidationError{}

// Validate checks the field values on BranchNode with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *BranchNode) Validate() error {
	if m == nil {
		return nil
	}

	if v, ok := interface{}(m.GetIfElse()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BranchNodeValidationError{
				field:  "IfElse",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	return nil
}

// BranchNodeValidationError is the validation error returned by
// BranchNode.Validate if the designated constraints aren't met.
type BranchNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BranchNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BranchNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BranchNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BranchNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BranchNodeValidationError) ErrorName() string { return "BranchNodeValidationError" }

// Error satisfies the builtin error interface
func (e BranchNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBranchNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BranchNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BranchNodeValidationError{}

// Validate checks the field values on ClosureNode with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *ClosureNode) Validate() error {
	if m == nil {
		return nil
	}

	if v, ok := interface{}(m.GetClosureType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClosureNodeValidationError{
				field:  "ClosureType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	return nil
}

// ClosureNodeValidationError is the validation error returned by
// ClosureNode.Validate if the designated constraints aren't met.
type ClosureNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClosureNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClosureNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClosureNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClosureNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClosureNodeValidationError) ErrorName() string { return "ClosureNodeValidationError" }

// Error satisfies the builtin error interface
func (e ClosureNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClosureNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClosureNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClosureNodeValidationError{}

// Validate checks the field values on TaskNode with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *TaskNode) Validate() error {
	if m == nil {
		return nil
	}

	switch m.Reference.(type) {

	case *TaskNode_ReferenceId:

		if v, ok := interface{}(m.GetReferenceId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TaskNodeValidationError{
					field:  "ReferenceId",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// TaskNodeValidationError is the validation error returned by
// TaskNode.Validate if the designated constraints aren't met.
type TaskNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaskNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaskNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaskNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaskNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaskNodeValidationError) ErrorName() string { return "TaskNodeValidationError" }

// Error satisfies the builtin error interface
func (e TaskNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaskNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaskNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaskNodeValidationError{}

// Validate checks the field values on WorkflowNode with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *WorkflowNode) Validate() error {
	if m == nil {
		return nil
	}

	switch m.Reference.(type) {

	case *WorkflowNode_LaunchplanRef:

		if v, ok := interface{}(m.GetLaunchplanRef()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WorkflowNodeValidationError{
					field:  "LaunchplanRef",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *WorkflowNode_SubWorkflowRef:

		if v, ok := interface{}(m.GetSubWorkflowRef()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WorkflowNodeValidationError{
					field:  "SubWorkflowRef",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// WorkflowNodeValidationError is the validation error returned by
// WorkflowNode.Validate if the designated constraints aren't met.
type WorkflowNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WorkflowNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WorkflowNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WorkflowNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WorkflowNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WorkflowNodeValidationError) ErrorName() string { return "WorkflowNodeValidationError" }

// Error satisfies the builtin error interface
func (e WorkflowNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWorkflowNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WorkflowNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WorkflowNodeValidationError{}

// Validate checks the field values on NodeMetadata with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *NodeMetadata) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Name

	if v, ok := interface{}(m.GetTimeout()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeMetadataValidationError{
				field:  "Timeout",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetRetries()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeMetadataValidationError{
				field:  "Retries",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	return nil
}

// NodeMetadataValidationError is the validation error returned by
// NodeMetadata.Validate if the designated constraints aren't met.
type NodeMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeMetadataValidationError) ErrorName() string { return "NodeMetadataValidationError" }

// Error satisfies the builtin error interface
func (e NodeMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeMetadataValidationError{}

// Validate checks the field values on Alias with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *Alias) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Var

	// no validation rules for Alias

	return nil
}

// AliasValidationError is the validation error returned by Alias.Validate if
// the designated constraints aren't met.
type AliasValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AliasValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AliasValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AliasValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AliasValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AliasValidationError) ErrorName() string { return "AliasValidationError" }

// Error satisfies the builtin error interface
func (e AliasValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAlias.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AliasValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AliasValidationError{}

// Validate checks the field values on Node with the rules defined in the proto
// definition for this message. If any rules are violated, an error is returned.
func (m *Node) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Id

	if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetInputs() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  fmt.Sprintf("Inputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetOutputAliases() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  fmt.Sprintf("OutputAliases[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	switch m.Target.(type) {

	case *Node_TaskNode:

		if v, ok := interface{}(m.GetTaskNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "TaskNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_WorkflowNode:

		if v, ok := interface{}(m.GetWorkflowNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "WorkflowNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_BranchNode:

		if v, ok := interface{}(m.GetBranchNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "BranchNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_ClosureNode:

		if v, ok := interface{}(m.GetClosureNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "ClosureNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// NodeValidationError is the validation error returned by Node.Validate if the
// designated constraints aren't met.
type NodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeValidationError) ErrorName() string { return "NodeValidationError" }

// Error satisfies the builtin error interface
func (e NodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeValidationError{}

// Validate checks the field values on WorkflowMetadata with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned.
func (m *WorkflowMetadata) Validate() error {
	if m == nil {
		return nil
	}

	return nil
}

// WorkflowMetadataValidationError is the validation error returned by
// WorkflowMetadata.Validate if the designated constraints aren't met.
type WorkflowMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WorkflowMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WorkflowMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WorkflowMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WorkflowMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WorkflowMetadataValidationError) ErrorName() string { return "WorkflowMetadataValidationError" }

// Error satisfies the builtin error interface
func (e WorkflowMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWorkflowMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WorkflowMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WorkflowMetadataValidationError{}

// Validate checks the field values on WorkflowTemplate with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned.
func (m *WorkflowTemplate) Validate() error {
	if m == nil {
		return nil
	}

	if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WorkflowTemplateValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WorkflowTemplateValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetInterface()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WorkflowTemplateValidationError{
				field:  "Interface",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetNodes() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WorkflowTemplateValidationError{
					field:  fmt.Sprintf("Nodes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetOutputs() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WorkflowTemplateValidationError{
					field:  fmt.Sprintf("Outputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if v, ok := interface{}(m.GetFailureNode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WorkflowTemplateValidationError{
				field:  "FailureNode",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	return nil
}

// WorkflowTemplateValidationError is the validation error returned by
// WorkflowTemplate.Validate if the designated constraints aren't met.
type WorkflowTemplateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WorkflowTemplateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WorkflowTemplateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WorkflowTemplateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WorkflowTemplateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WorkflowTemplateValidationError) ErrorName() string { return "WorkflowTemplateValidationError" }

// Error satisfies the builtin error interface
func (e WorkflowTemplateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWorkflowTemplate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WorkflowTemplateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WorkflowTemplateValidationError{}
