// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flyteidl/service/admin.proto

#include "flyteidl/service/admin.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// This is a temporary google only hack
#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
#include "third_party/protobuf/version.h"
#endif
// @@protoc_insertion_point(includes)
namespace flyteidl {
namespace service {
}  // namespace service
}  // namespace flyteidl
namespace protobuf_flyteidl_2fservice_2fadmin_2eproto {
const ::google::protobuf::uint32 TableStruct::offsets[1] = {};
static const ::google::protobuf::internal::MigrationSchema* schemas = NULL;
static const ::google::protobuf::Message* const* file_default_instances = NULL;

void protobuf_AssignDescriptors() {
  AddDescriptors();
  ::google::protobuf::MessageFactory* factory = NULL;
  AssignDescriptors(
      "flyteidl/service/admin.proto", schemas, file_default_instances, TableStruct::offsets, factory,
      NULL, NULL, NULL);
}

void protobuf_AssignDescriptorsOnce() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &protobuf_AssignDescriptors);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_PROTOBUF_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
}

void AddDescriptorsImpl() {
  InitDefaults();
  static const char descriptor[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
      "\n\034flyteidl/service/admin.proto\022\020flyteidl"
      ".service\032\034google/api/annotations.proto\032\034"
      "flyteidl/admin/project.proto\032\031flyteidl/a"
      "dmin/task.proto\032\035flyteidl/admin/workflow"
      ".proto\032 flyteidl/admin/launch_plan.proto"
      "\032\032flyteidl/admin/event.proto\032\036flyteidl/a"
      "dmin/execution.proto\032#flyteidl/admin/nod"
      "e_execution.proto\032#flyteidl/admin/task_e"
      "xecution.proto\032\033flyteidl/admin/common.pr"
      "oto\032,protoc-gen-swagger/options/annotati"
      "ons.proto2\245@\n\014AdminService\022\230\001\n\nCreateTas"
      "k\022!.flyteidl.admin.TaskCreateRequest\032\".f"
      "lyteidl.admin.TaskCreateResponse\"C\202\323\344\223\002\022"
      "\"\r/api/v1/tasks:\001*\222A(\032&Create and regist"
      "er a task definition.\022\262\001\n\007GetTask\022 .flyt"
      "eidl.admin.ObjectGetRequest\032\024.flyteidl.a"
      "dmin.Task\"o\202\323\344\223\002\?\022=/api/v1/tasks/{id.pro"
      "ject}/{id.domain}/{id.name}/{id.version}"
      "\222A\'\032%Retrieve an existing task definitio"
      "n.\022\336\001\n\013ListTaskIds\0220.flyteidl.admin.Name"
      "dEntityIdentifierListRequest\032).flyteidl."
      "admin.NamedEntityIdentifierList\"r\202\323\344\223\002%\022"
      "#/api/v1/task_ids/{project}/{domain}\222AD\032"
      "BFetch existing task definition identifi"
      "ers matching input filters.\022\353\001\n\tListTask"
      "s\022#.flyteidl.admin.ResourceListRequest\032\030"
      ".flyteidl.admin.TaskList\"\236\001\202\323\344\223\002\\\0220/api/"
      "v1/tasks/{id.project}/{id.domain}/{id.na"
      "me}Z(\022&/api/v1/tasks/{id.project}/{id.do"
      "main}\222A9\0327Fetch existing task definition"
      "s matching input filters.\022\254\001\n\016CreateWork"
      "flow\022%.flyteidl.admin.WorkflowCreateRequ"
      "est\032&.flyteidl.admin.WorkflowCreateRespo"
      "nse\"K\202\323\344\223\002\026\"\021/api/v1/workflows:\001*\222A,\032*Cr"
      "eate and register a workflow definition."
      "\022\302\001\n\013GetWorkflow\022 .flyteidl.admin.Object"
      "GetRequest\032\030.flyteidl.admin.Workflow\"w\202\323"
      "\344\223\002C\022A/api/v1/workflows/{id.project}/{id"
      ".domain}/{id.name}/{id.version}\222A+\032)Retr"
      "ieve an existing workflow definition.\022\355\001"
      "\n\017ListWorkflowIds\0220.flyteidl.admin.Named"
      "EntityIdentifierListRequest\032).flyteidl.a"
      "dmin.NamedEntityIdentifierList\"}\202\323\344\223\002)\022\'"
      "/api/v1/workflow_ids/{project}/{domain}\222"
      "AK\032IFetch an existing workflow definitio"
      "n identifiers matching input filters.\022\377\001"
      "\n\rListWorkflows\022#.flyteidl.admin.Resourc"
      "eListRequest\032\034.flyteidl.admin.WorkflowLi"
      "st\"\252\001\202\323\344\223\002d\0224/api/v1/workflows/{id.proje"
      "ct}/{id.domain}/{id.name}Z,\022*/api/v1/wor"
      "kflows/{id.project}/{id.domain}\222A=\032;Fetc"
      "h existing workflow definitions matching"
      " input filters.\022\270\001\n\020CreateLaunchPlan\022\'.f"
      "lyteidl.admin.LaunchPlanCreateRequest\032(."
      "flyteidl.admin.LaunchPlanCreateResponse\""
      "Q\202\323\344\223\002\031\"\024/api/v1/launch_plans:\001*\222A/\032-Cre"
      "ate and register a launch plan definitio"
      "n.\022\314\001\n\rGetLaunchPlan\022 .flyteidl.admin.Ob"
      "jectGetRequest\032\032.flyteidl.admin.LaunchPl"
      "an\"}\202\323\344\223\002F\022D/api/v1/launch_plans/{id.pro"
      "ject}/{id.domain}/{id.name}/{id.version}"
      "\222A.\032,Retrieve an existing launch plan de"
      "finition.\022\363\001\n\023GetActiveLaunchPlan\022\'.flyt"
      "eidl.admin.ActiveLaunchPlanRequest\032\032.fly"
      "teidl.admin.LaunchPlan\"\226\001\202\323\344\223\002@\022>/api/v1"
      "/active_launch_plans/{id.project}/{id.do"
      "main}/{id.name}\222AM\032KRetrieve the active "
      "launch plan version specified by input r"
      "equest filters.\022\353\001\n\025ListActiveLaunchPlan"
      "s\022+.flyteidl.admin.ActiveLaunchPlanListR"
      "equest\032\036.flyteidl.admin.LaunchPlanList\"\204"
      "\001\202\323\344\223\0020\022./api/v1/active_launch_plans/{pr"
      "oject}/{domain}\222AK\032IFetch the active lau"
      "nch plan versions specified by input req"
      "uest filters.\022\363\001\n\021ListLaunchPlanIds\0220.fl"
      "yteidl.admin.NamedEntityIdentifierListRe"
      "quest\032).flyteidl.admin.NamedEntityIdenti"
      "fierList\"\200\001\202\323\344\223\002,\022*/api/v1/launch_plan_i"
      "ds/{project}/{domain}\222AK\032IFetch existing"
      " launch plan definition identifiers matc"
      "hing input filters.\022\214\002\n\017ListLaunchPlans\022"
      "#.flyteidl.admin.ResourceListRequest\032\036.f"
      "lyteidl.admin.LaunchPlanList\"\263\001\202\323\344\223\002j\0227/"
      "api/v1/launch_plans/{id.project}/{id.dom"
      "ain}/{id.name}Z/\022-/api/v1/launch_plans/{"
      "id.project}/{id.domain}\222A@\032>Fetch existi"
      "ng launch plan definitions matching inpu"
      "t filters.\022\364\001\n\020UpdateLaunchPlan\022\'.flytei"
      "dl.admin.LaunchPlanUpdateRequest\032(.flyte"
      "idl.admin.LaunchPlanUpdateResponse\"\214\001\202\323\344"
      "\223\002I\032D/api/v1/launch_plans/{id.project}/{"
      "id.domain}/{id.name}/{id.version}:\001*\222A:\032"
      "8Update the status of an existing launch"
      " plan definition.\022\242\001\n\017CreateExecution\022&."
      "flyteidl.admin.ExecutionCreateRequest\032\'."
      "flyteidl.admin.ExecutionCreateResponse\">"
      "\202\323\344\223\002\027\"\022/api/v1/executions:\001*\222A\036\032\034Create"
      " a workflow execution.\022\261\001\n\021RelaunchExecu"
      "tion\022(.flyteidl.admin.ExecutionRelaunchR"
      "equest\032\'.flyteidl.admin.ExecutionCreateR"
      "esponse\"I\202\323\344\223\002 \"\033/api/v1/executions/rela"
      "unch:\001*\222A \032\036Relaunch a workflow executio"
      "n.\022\302\001\n\014GetExecution\022+.flyteidl.admin.Wor"
      "kflowExecutionGetRequest\032\031.flyteidl.admi"
      "n.Execution\"j\202\323\344\223\0027\0225/api/v1/executions/"
      "{id.project}/{id.domain}/{id.name}\222A*\032(R"
      "etrieve an existing workflow execution.\022"
      "\202\002\n\020GetExecutionData\022/.flyteidl.admin.Wo"
      "rkflowExecutionGetDataRequest\0320.flyteidl"
      ".admin.WorkflowExecutionGetDataResponse\""
      "\212\001\202\323\344\223\002<\022:/api/v1/data/executions/{id.pr"
      "oject}/{id.domain}/{id.name}\222AE\032CRetriev"
      "e input and output data from an existing"
      " workflow execution.\022\310\001\n\016ListExecutions\022"
      "#.flyteidl.admin.ResourceListRequest\032\035.f"
      "lyteidl.admin.ExecutionList\"r\202\323\344\223\002-\022+/ap"
      "i/v1/executions/{id.project}/{id.domain}"
      "\222A<\032:Fetch existing workflow executions "
      "matching input filters.\022\364\001\n\022TerminateExe"
      "cution\022).flyteidl.admin.ExecutionTermina"
      "teRequest\032*.flyteidl.admin.ExecutionTerm"
      "inateResponse\"\206\001\202\323\344\223\002:*5/api/v1/executio"
      "ns/{id.project}/{id.domain}/{id.name}:\001*"
      "\222AC\032ATerminate the active workflow execu"
      "tion specified in the request.\022\374\001\n\020GetNo"
      "deExecution\022\'.flyteidl.admin.NodeExecuti"
      "onGetRequest\032\035.flyteidl.admin.NodeExecut"
      "ion\"\237\001\202\323\344\223\002p\022n/api/v1/node_executions/{i"
      "d.execution_id.project}/{id.execution_id"
      ".domain}/{id.execution_id.name}/{id.node"
      "_id}\222A&\032$Retrieve an existing node execu"
      "tion.\022\232\002\n\022ListNodeExecutions\022(.flyteidl."
      "admin.NodeExecutionListRequest\032!.flyteid"
      "l.admin.NodeExecutionList\"\266\001\202\323\344\223\002u\022s/api"
      "/v1/node_executions/{workflow_execution_"
      "id.project}/{workflow_execution_id.domai"
      "n}/{workflow_execution_id.name}\222A8\0326Fetc"
      "h existing node executions matching inpu"
      "t filters.\022\357\004\n\031ListNodeExecutionsForTask"
      "\022/.flyteidl.admin.NodeExecutionForTaskLi"
      "stRequest\032!.flyteidl.admin.NodeExecution"
      "List\"\375\003\202\323\344\223\002\254\003\022\251\003/api/v1/children/task_e"
      "xecutions/{task_execution_id.node_execut"
      "ion_id.execution_id.project}/{task_execu"
      "tion_id.node_execution_id.execution_id.d"
      "omain}/{task_execution_id.node_execution"
      "_id.execution_id.name}/{task_execution_i"
      "d.node_execution_id.node_id}/{task_execu"
      "tion_id.task_id.project}/{task_execution"
      "_id.task_id.domain}/{task_execution_id.t"
      "ask_id.name}/{task_execution_id.task_id."
      "version}/{task_execution_id.retry_attemp"
      "t}\222AG\032EFetch child node executions launc"
      "hed by the specified task execution.\022\263\002\n"
      "\024GetNodeExecutionData\022+.flyteidl.admin.N"
      "odeExecutionGetDataRequest\032,.flyteidl.ad"
      "min.NodeExecutionGetDataResponse\"\277\001\202\323\344\223\002"
      "u\022s/api/v1/data/node_executions/{id.exec"
      "ution_id.project}/{id.execution_id.domai"
      "n}/{id.execution_id.name}/{id.node_id}\222A"
      "A\032\?Retrieve input and output data from a"
      "n existing node execution.\022\227\001\n\017RegisterP"
      "roject\022&.flyteidl.admin.ProjectRegisterR"
      "equest\032\'.flyteidl.admin.ProjectRegisterR"
      "esponse\"3\202\323\344\223\002\025\"\020/api/v1/projects:\001*\222A\025\032"
      "\023Register a project.\022\205\001\n\014ListProjects\022\"."
      "flyteidl.admin.ProjectListRequest\032\030.flyt"
      "eidl.admin.Projects\"7\202\323\344\223\002\022\022\020/api/v1/pro"
      "jects\222A\034\032\032Fetch registered projects.\022\335\001\n"
      "\023CreateWorkflowEvent\022-.flyteidl.admin.Wo"
      "rkflowExecutionEventRequest\032..flyteidl.a"
      "dmin.WorkflowExecutionEventResponse\"g\202\323\344"
      "\223\002\035\"\030/api/v1/events/workflows:\001*\222AA\032\?Cre"
      "ate a workflow execution event recording"
      " a phase transition.\022\311\001\n\017CreateNodeEvent"
      "\022).flyteidl.admin.NodeExecutionEventRequ"
      "est\032*.flyteidl.admin.NodeExecutionEventR"
      "esponse\"_\202\323\344\223\002\031\"\024/api/v1/events/nodes:\001*"
      "\222A=\032;Create a node execution event recor"
      "ding a phase transition.\022\311\001\n\017CreateTaskE"
      "vent\022).flyteidl.admin.TaskExecutionEvent"
      "Request\032*.flyteidl.admin.TaskExecutionEv"
      "entResponse\"_\202\323\344\223\002\031\"\024/api/v1/events/task"
      "s:\001*\222A=\032;Create a task execution event r"
      "ecording a phase transition.\022\251\003\n\020GetTask"
      "Execution\022\'.flyteidl.admin.TaskExecution"
      "GetRequest\032\035.flyteidl.admin.TaskExecutio"
      "n\"\314\002\202\323\344\223\002\234\002\022\231\002/api/v1/task_executions/{i"
      "d.node_execution_id.execution_id.project"
      "}/{id.node_execution_id.execution_id.dom"
      "ain}/{id.node_execution_id.execution_id."
      "name}/{id.node_execution_id.node_id}/{id"
      ".task_id.project}/{id.task_id.domain}/{i"
      "d.task_id.name}/{id.task_id.version}/{id"
      ".retry_attempt}\222A&\032$Retrieve an existing"
      " task execution.\022\323\002\n\022ListTaskExecutions\022"
      "(.flyteidl.admin.TaskExecutionListReques"
      "t\032!.flyteidl.admin.TaskExecutionList\"\357\001\202"
      "\323\344\223\002\255\001\022\252\001/api/v1/task_executions/{node_e"
      "xecution_id.execution_id.project}/{node_"
      "execution_id.execution_id.domain}/{node_"
      "execution_id.execution_id.name}/{node_ex"
      "ecution_id.node_id}\222A8\0326Fetch existing t"
      "ask executions matching input filters.\022\340"
      "\003\n\024GetTaskExecutionData\022+.flyteidl.admin"
      ".TaskExecutionGetDataRequest\032,.flyteidl."
      "admin.TaskExecutionGetDataResponse\"\354\002\202\323\344"
      "\223\002\241\002\022\236\002/api/v1/data/task_executions/{id."
      "node_execution_id.execution_id.project}/"
      "{id.node_execution_id.execution_id.domai"
      "n}/{id.node_execution_id.execution_id.na"
      "me}/{id.node_execution_id.node_id}/{id.t"
      "ask_id.project}/{id.task_id.domain}/{id."
      "task_id.name}/{id.task_id.version}/{id.r"
      "etry_attempt}\222AA\032\?Retrieve input and out"
      "put data from an existing task execution"
      ".B5Z3github.com/lyft/flyteidl/gen/pb-go/"
      "flyteidl/serviceb\006proto3"
  };
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      descriptor, 8704);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "flyteidl/service/admin.proto", &protobuf_RegisterTypes);
  ::protobuf_google_2fapi_2fannotations_2eproto::AddDescriptors();
  ::protobuf_flyteidl_2fadmin_2fproject_2eproto::AddDescriptors();
  ::protobuf_flyteidl_2fadmin_2ftask_2eproto::AddDescriptors();
  ::protobuf_flyteidl_2fadmin_2fworkflow_2eproto::AddDescriptors();
  ::protobuf_flyteidl_2fadmin_2flaunch_5fplan_2eproto::AddDescriptors();
  ::protobuf_flyteidl_2fadmin_2fevent_2eproto::AddDescriptors();
  ::protobuf_flyteidl_2fadmin_2fexecution_2eproto::AddDescriptors();
  ::protobuf_flyteidl_2fadmin_2fnode_5fexecution_2eproto::AddDescriptors();
  ::protobuf_flyteidl_2fadmin_2ftask_5fexecution_2eproto::AddDescriptors();
  ::protobuf_flyteidl_2fadmin_2fcommon_2eproto::AddDescriptors();
  ::protobuf_protoc_2dgen_2dswagger_2foptions_2fannotations_2eproto::AddDescriptors();
}

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}
// Force AddDescriptors() to be called at dynamic initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;
}  // namespace protobuf_flyteidl_2fservice_2fadmin_2eproto
namespace flyteidl {
namespace service {

// @@protoc_insertion_point(namespace_scope)
}  // namespace service
}  // namespace flyteidl

// @@protoc_insertion_point(global_scope)
