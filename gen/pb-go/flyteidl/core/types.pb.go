// Code generated by protoc-gen-go. DO NOT EDIT.
// source: flyteidl/core/types.proto

package core // import "github.com/lyft/flyteidl/gen/pb-go/flyteidl/core"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Define a set of simple types.
type SimpleType int32

const (
	SimpleType_NONE     SimpleType = 0
	SimpleType_INTEGER  SimpleType = 1
	SimpleType_FLOAT    SimpleType = 2
	SimpleType_STRING   SimpleType = 3
	SimpleType_BOOLEAN  SimpleType = 4
	SimpleType_DATETIME SimpleType = 5
	SimpleType_DURATION SimpleType = 6
	SimpleType_BINARY   SimpleType = 8
	SimpleType_WAITABLE SimpleType = 9
	SimpleType_ERROR    SimpleType = 10
)

var SimpleType_name = map[int32]string{
	0:  "NONE",
	1:  "INTEGER",
	2:  "FLOAT",
	3:  "STRING",
	4:  "BOOLEAN",
	5:  "DATETIME",
	6:  "DURATION",
	8:  "BINARY",
	9:  "WAITABLE",
	10: "ERROR",
}
var SimpleType_value = map[string]int32{
	"NONE":     0,
	"INTEGER":  1,
	"FLOAT":    2,
	"STRING":   3,
	"BOOLEAN":  4,
	"DATETIME": 5,
	"DURATION": 6,
	"BINARY":   8,
	"WAITABLE": 9,
	"ERROR":    10,
}

func (x SimpleType) String() string {
	return proto.EnumName(SimpleType_name, int32(x))
}
func (SimpleType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_types_279f7f2fcb144669, []int{0}
}

type SchemaType_SchemaColumn_SchemaColumnType int32

const (
	SchemaType_SchemaColumn_INTEGER  SchemaType_SchemaColumn_SchemaColumnType = 0
	SchemaType_SchemaColumn_FLOAT    SchemaType_SchemaColumn_SchemaColumnType = 1
	SchemaType_SchemaColumn_STRING   SchemaType_SchemaColumn_SchemaColumnType = 2
	SchemaType_SchemaColumn_DATETIME SchemaType_SchemaColumn_SchemaColumnType = 3
	SchemaType_SchemaColumn_DURATION SchemaType_SchemaColumn_SchemaColumnType = 4
	SchemaType_SchemaColumn_BOOLEAN  SchemaType_SchemaColumn_SchemaColumnType = 5
)

var SchemaType_SchemaColumn_SchemaColumnType_name = map[int32]string{
	0: "INTEGER",
	1: "FLOAT",
	2: "STRING",
	3: "DATETIME",
	4: "DURATION",
	5: "BOOLEAN",
}
var SchemaType_SchemaColumn_SchemaColumnType_value = map[string]int32{
	"INTEGER":  0,
	"FLOAT":    1,
	"STRING":   2,
	"DATETIME": 3,
	"DURATION": 4,
	"BOOLEAN":  5,
}

func (x SchemaType_SchemaColumn_SchemaColumnType) String() string {
	return proto.EnumName(SchemaType_SchemaColumn_SchemaColumnType_name, int32(x))
}
func (SchemaType_SchemaColumn_SchemaColumnType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_types_279f7f2fcb144669, []int{0, 0, 0}
}

type BlobType_BlobDimensionality int32

const (
	BlobType_Single    BlobType_BlobDimensionality = 0
	BlobType_Multipart BlobType_BlobDimensionality = 1
)

var BlobType_BlobDimensionality_name = map[int32]string{
	0: "Single",
	1: "Multipart",
}
var BlobType_BlobDimensionality_value = map[string]int32{
	"Single":    0,
	"Multipart": 1,
}

func (x BlobType_BlobDimensionality) String() string {
	return proto.EnumName(BlobType_BlobDimensionality_name, int32(x))
}
func (BlobType_BlobDimensionality) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_types_279f7f2fcb144669, []int{1, 0}
}

// Defines schema columns and types to strongly type-validate schemas interoperability.
type SchemaType struct {
	// A list of ordered columns this schema comprises of.
	Columns              []*SchemaType_SchemaColumn `protobuf:"bytes,3,rep,name=columns,proto3" json:"columns,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *SchemaType) Reset()         { *m = SchemaType{} }
func (m *SchemaType) String() string { return proto.CompactTextString(m) }
func (*SchemaType) ProtoMessage()    {}
func (*SchemaType) Descriptor() ([]byte, []int) {
	return fileDescriptor_types_279f7f2fcb144669, []int{0}
}
func (m *SchemaType) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SchemaType.Unmarshal(m, b)
}
func (m *SchemaType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SchemaType.Marshal(b, m, deterministic)
}
func (dst *SchemaType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaType.Merge(dst, src)
}
func (m *SchemaType) XXX_Size() int {
	return xxx_messageInfo_SchemaType.Size(m)
}
func (m *SchemaType) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaType.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaType proto.InternalMessageInfo

func (m *SchemaType) GetColumns() []*SchemaType_SchemaColumn {
	if m != nil {
		return m.Columns
	}
	return nil
}

type SchemaType_SchemaColumn struct {
	// A unique name -within the schema type- for the column
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The column type. This allows a limited set of types currently.
	Type                 SchemaType_SchemaColumn_SchemaColumnType `protobuf:"varint,2,opt,name=type,proto3,enum=flyteidl.core.SchemaType_SchemaColumn_SchemaColumnType" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                 `json:"-"`
	XXX_unrecognized     []byte                                   `json:"-"`
	XXX_sizecache        int32                                    `json:"-"`
}

func (m *SchemaType_SchemaColumn) Reset()         { *m = SchemaType_SchemaColumn{} }
func (m *SchemaType_SchemaColumn) String() string { return proto.CompactTextString(m) }
func (*SchemaType_SchemaColumn) ProtoMessage()    {}
func (*SchemaType_SchemaColumn) Descriptor() ([]byte, []int) {
	return fileDescriptor_types_279f7f2fcb144669, []int{0, 0}
}
func (m *SchemaType_SchemaColumn) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SchemaType_SchemaColumn.Unmarshal(m, b)
}
func (m *SchemaType_SchemaColumn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SchemaType_SchemaColumn.Marshal(b, m, deterministic)
}
func (dst *SchemaType_SchemaColumn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaType_SchemaColumn.Merge(dst, src)
}
func (m *SchemaType_SchemaColumn) XXX_Size() int {
	return xxx_messageInfo_SchemaType_SchemaColumn.Size(m)
}
func (m *SchemaType_SchemaColumn) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaType_SchemaColumn.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaType_SchemaColumn proto.InternalMessageInfo

func (m *SchemaType_SchemaColumn) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SchemaType_SchemaColumn) GetType() SchemaType_SchemaColumn_SchemaColumnType {
	if m != nil {
		return m.Type
	}
	return SchemaType_SchemaColumn_INTEGER
}

// Defines type behavior for blob objects
type BlobType struct {
	// Format can be a free form string understood by SDK/UI etc like
	// csv, parquet etc
	Format               string                      `protobuf:"bytes,1,opt,name=format,proto3" json:"format,omitempty"`
	Dimensionality       BlobType_BlobDimensionality `protobuf:"varint,2,opt,name=dimensionality,proto3,enum=flyteidl.core.BlobType_BlobDimensionality" json:"dimensionality,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *BlobType) Reset()         { *m = BlobType{} }
func (m *BlobType) String() string { return proto.CompactTextString(m) }
func (*BlobType) ProtoMessage()    {}
func (*BlobType) Descriptor() ([]byte, []int) {
	return fileDescriptor_types_279f7f2fcb144669, []int{1}
}
func (m *BlobType) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BlobType.Unmarshal(m, b)
}
func (m *BlobType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BlobType.Marshal(b, m, deterministic)
}
func (dst *BlobType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlobType.Merge(dst, src)
}
func (m *BlobType) XXX_Size() int {
	return xxx_messageInfo_BlobType.Size(m)
}
func (m *BlobType) XXX_DiscardUnknown() {
	xxx_messageInfo_BlobType.DiscardUnknown(m)
}

var xxx_messageInfo_BlobType proto.InternalMessageInfo

func (m *BlobType) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

func (m *BlobType) GetDimensionality() BlobType_BlobDimensionality {
	if m != nil {
		return m.Dimensionality
	}
	return BlobType_Single
}

// Defines a strong type to allow type checking between interfaces.
type LiteralType struct {
	// Types that are valid to be assigned to Type:
	//	*LiteralType_Simple
	//	*LiteralType_Schema
	//	*LiteralType_CollectionType
	//	*LiteralType_MapValueType
	//	*LiteralType_Blob
	Type                 isLiteralType_Type `protobuf_oneof:"type"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *LiteralType) Reset()         { *m = LiteralType{} }
func (m *LiteralType) String() string { return proto.CompactTextString(m) }
func (*LiteralType) ProtoMessage()    {}
func (*LiteralType) Descriptor() ([]byte, []int) {
	return fileDescriptor_types_279f7f2fcb144669, []int{2}
}
func (m *LiteralType) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LiteralType.Unmarshal(m, b)
}
func (m *LiteralType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LiteralType.Marshal(b, m, deterministic)
}
func (dst *LiteralType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiteralType.Merge(dst, src)
}
func (m *LiteralType) XXX_Size() int {
	return xxx_messageInfo_LiteralType.Size(m)
}
func (m *LiteralType) XXX_DiscardUnknown() {
	xxx_messageInfo_LiteralType.DiscardUnknown(m)
}

var xxx_messageInfo_LiteralType proto.InternalMessageInfo

type isLiteralType_Type interface {
	isLiteralType_Type()
}

type LiteralType_Simple struct {
	Simple SimpleType `protobuf:"varint,1,opt,name=simple,proto3,enum=flyteidl.core.SimpleType,oneof"`
}

type LiteralType_Schema struct {
	Schema *SchemaType `protobuf:"bytes,2,opt,name=schema,proto3,oneof"`
}

type LiteralType_CollectionType struct {
	CollectionType *LiteralType `protobuf:"bytes,3,opt,name=collection_type,json=collectionType,proto3,oneof"`
}

type LiteralType_MapValueType struct {
	MapValueType *LiteralType `protobuf:"bytes,4,opt,name=map_value_type,json=mapValueType,proto3,oneof"`
}

type LiteralType_Blob struct {
	Blob *BlobType `protobuf:"bytes,5,opt,name=blob,proto3,oneof"`
}

func (*LiteralType_Simple) isLiteralType_Type() {}

func (*LiteralType_Schema) isLiteralType_Type() {}

func (*LiteralType_CollectionType) isLiteralType_Type() {}

func (*LiteralType_MapValueType) isLiteralType_Type() {}

func (*LiteralType_Blob) isLiteralType_Type() {}

func (m *LiteralType) GetType() isLiteralType_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *LiteralType) GetSimple() SimpleType {
	if x, ok := m.GetType().(*LiteralType_Simple); ok {
		return x.Simple
	}
	return SimpleType_NONE
}

func (m *LiteralType) GetSchema() *SchemaType {
	if x, ok := m.GetType().(*LiteralType_Schema); ok {
		return x.Schema
	}
	return nil
}

func (m *LiteralType) GetCollectionType() *LiteralType {
	if x, ok := m.GetType().(*LiteralType_CollectionType); ok {
		return x.CollectionType
	}
	return nil
}

func (m *LiteralType) GetMapValueType() *LiteralType {
	if x, ok := m.GetType().(*LiteralType_MapValueType); ok {
		return x.MapValueType
	}
	return nil
}

func (m *LiteralType) GetBlob() *BlobType {
	if x, ok := m.GetType().(*LiteralType_Blob); ok {
		return x.Blob
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*LiteralType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _LiteralType_OneofMarshaler, _LiteralType_OneofUnmarshaler, _LiteralType_OneofSizer, []interface{}{
		(*LiteralType_Simple)(nil),
		(*LiteralType_Schema)(nil),
		(*LiteralType_CollectionType)(nil),
		(*LiteralType_MapValueType)(nil),
		(*LiteralType_Blob)(nil),
	}
}

func _LiteralType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*LiteralType)
	// type
	switch x := m.Type.(type) {
	case *LiteralType_Simple:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Simple))
	case *LiteralType_Schema:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Schema); err != nil {
			return err
		}
	case *LiteralType_CollectionType:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CollectionType); err != nil {
			return err
		}
	case *LiteralType_MapValueType:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MapValueType); err != nil {
			return err
		}
	case *LiteralType_Blob:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Blob); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("LiteralType.Type has unexpected type %T", x)
	}
	return nil
}

func _LiteralType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*LiteralType)
	switch tag {
	case 1: // type.simple
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &LiteralType_Simple{SimpleType(x)}
		return true, err
	case 2: // type.schema
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SchemaType)
		err := b.DecodeMessage(msg)
		m.Type = &LiteralType_Schema{msg}
		return true, err
	case 3: // type.collection_type
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LiteralType)
		err := b.DecodeMessage(msg)
		m.Type = &LiteralType_CollectionType{msg}
		return true, err
	case 4: // type.map_value_type
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LiteralType)
		err := b.DecodeMessage(msg)
		m.Type = &LiteralType_MapValueType{msg}
		return true, err
	case 5: // type.blob
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BlobType)
		err := b.DecodeMessage(msg)
		m.Type = &LiteralType_Blob{msg}
		return true, err
	default:
		return false, nil
	}
}

func _LiteralType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*LiteralType)
	// type
	switch x := m.Type.(type) {
	case *LiteralType_Simple:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.Simple))
	case *LiteralType_Schema:
		s := proto.Size(x.Schema)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LiteralType_CollectionType:
		s := proto.Size(x.CollectionType)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LiteralType_MapValueType:
		s := proto.Size(x.MapValueType)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LiteralType_Blob:
		s := proto.Size(x.Blob)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A reference to an output produced by a node. The type can be retrieved -and validated- from
// the underlying interface of the node.
type OutputReference struct {
	// Node id must exist at the graph layer.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// Variable name must refer to an output variable for the node.
	Var                  string   `protobuf:"bytes,2,opt,name=var,proto3" json:"var,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OutputReference) Reset()         { *m = OutputReference{} }
func (m *OutputReference) String() string { return proto.CompactTextString(m) }
func (*OutputReference) ProtoMessage()    {}
func (*OutputReference) Descriptor() ([]byte, []int) {
	return fileDescriptor_types_279f7f2fcb144669, []int{3}
}
func (m *OutputReference) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OutputReference.Unmarshal(m, b)
}
func (m *OutputReference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OutputReference.Marshal(b, m, deterministic)
}
func (dst *OutputReference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputReference.Merge(dst, src)
}
func (m *OutputReference) XXX_Size() int {
	return xxx_messageInfo_OutputReference.Size(m)
}
func (m *OutputReference) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputReference.DiscardUnknown(m)
}

var xxx_messageInfo_OutputReference proto.InternalMessageInfo

func (m *OutputReference) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

func (m *OutputReference) GetVar() string {
	if m != nil {
		return m.Var
	}
	return ""
}

// Represents an error thrown from a node.
type Error struct {
	// The node id that threw the error.
	FailedNodeId string `protobuf:"bytes,1,opt,name=failed_node_id,json=failedNodeId,proto3" json:"failed_node_id,omitempty"`
	// Error message thrown.
	Message              string   `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Error) Reset()         { *m = Error{} }
func (m *Error) String() string { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()    {}
func (*Error) Descriptor() ([]byte, []int) {
	return fileDescriptor_types_279f7f2fcb144669, []int{4}
}
func (m *Error) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Error.Unmarshal(m, b)
}
func (m *Error) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Error.Marshal(b, m, deterministic)
}
func (dst *Error) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Error.Merge(dst, src)
}
func (m *Error) XXX_Size() int {
	return xxx_messageInfo_Error.Size(m)
}
func (m *Error) XXX_DiscardUnknown() {
	xxx_messageInfo_Error.DiscardUnknown(m)
}

var xxx_messageInfo_Error proto.InternalMessageInfo

func (m *Error) GetFailedNodeId() string {
	if m != nil {
		return m.FailedNodeId
	}
	return ""
}

func (m *Error) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func init() {
	proto.RegisterType((*SchemaType)(nil), "flyteidl.core.SchemaType")
	proto.RegisterType((*SchemaType_SchemaColumn)(nil), "flyteidl.core.SchemaType.SchemaColumn")
	proto.RegisterType((*BlobType)(nil), "flyteidl.core.BlobType")
	proto.RegisterType((*LiteralType)(nil), "flyteidl.core.LiteralType")
	proto.RegisterType((*OutputReference)(nil), "flyteidl.core.OutputReference")
	proto.RegisterType((*Error)(nil), "flyteidl.core.Error")
	proto.RegisterEnum("flyteidl.core.SimpleType", SimpleType_name, SimpleType_value)
	proto.RegisterEnum("flyteidl.core.SchemaType_SchemaColumn_SchemaColumnType", SchemaType_SchemaColumn_SchemaColumnType_name, SchemaType_SchemaColumn_SchemaColumnType_value)
	proto.RegisterEnum("flyteidl.core.BlobType_BlobDimensionality", BlobType_BlobDimensionality_name, BlobType_BlobDimensionality_value)
}

func init() { proto.RegisterFile("flyteidl/core/types.proto", fileDescriptor_types_279f7f2fcb144669) }

var fileDescriptor_types_279f7f2fcb144669 = []byte{
	// 608 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x54, 0xcb, 0x6e, 0xda, 0x40,
	0x14, 0xc5, 0x60, 0x5e, 0x17, 0x42, 0x46, 0xb3, 0x68, 0x48, 0x56, 0x91, 0x55, 0x55, 0x51, 0xa4,
	0xe0, 0x8a, 0x2c, 0xba, 0xe9, 0xa2, 0x76, 0xe3, 0x06, 0xab, 0xc4, 0x96, 0x26, 0x6e, 0xab, 0x76,
	0x83, 0x8c, 0x19, 0xc8, 0x48, 0x63, 0x8f, 0x65, 0x86, 0x48, 0xfc, 0x44, 0xff, 0xa1, 0xab, 0x7e,
	0x43, 0xff, 0xa2, 0x9f, 0x54, 0x79, 0x30, 0x01, 0x13, 0x55, 0xca, 0xee, 0x5e, 0xdf, 0x73, 0x8e,
	0xef, 0xe3, 0x68, 0xe0, 0x74, 0xce, 0xd7, 0x92, 0xb2, 0x19, 0x37, 0x23, 0x91, 0x51, 0x53, 0xae,
	0x53, 0xba, 0x1c, 0xa4, 0x99, 0x90, 0x02, 0x1f, 0x6d, 0x4b, 0x83, 0xbc, 0x64, 0xfc, 0xaa, 0x02,
	0xdc, 0x47, 0x0f, 0x34, 0x0e, 0x83, 0x75, 0x4a, 0xf1, 0x07, 0x68, 0x46, 0x82, 0xaf, 0xe2, 0x64,
	0xd9, 0xaf, 0x9d, 0xd7, 0x2e, 0x3a, 0xc3, 0x37, 0x83, 0x12, 0x7e, 0xb0, 0xc3, 0x16, 0xe1, 0x47,
	0x05, 0x27, 0x5b, 0xda, 0xd9, 0x5f, 0x0d, 0xba, 0xfb, 0x15, 0x8c, 0x41, 0x4f, 0xc2, 0x98, 0xf6,
	0xb5, 0x73, 0xed, 0xa2, 0x4d, 0x54, 0x8c, 0x3f, 0x83, 0x9e, 0xf7, 0xd4, 0xaf, 0x9e, 0x6b, 0x17,
	0xbd, 0xe1, 0xbb, 0x97, 0xfd, 0xa3, 0x94, 0xe4, 0x55, 0xa2, 0x44, 0x8c, 0x09, 0xa0, 0xc3, 0x0a,
	0xee, 0x40, 0xd3, 0xf5, 0x02, 0xe7, 0xd6, 0x21, 0xa8, 0x82, 0xdb, 0x50, 0xff, 0x34, 0xf6, 0xad,
	0x00, 0x69, 0x18, 0xa0, 0x71, 0x1f, 0x10, 0xd7, 0xbb, 0x45, 0x55, 0xdc, 0x85, 0xd6, 0x8d, 0x15,
	0x38, 0x81, 0x7b, 0xe7, 0xa0, 0x9a, 0xca, 0xbe, 0x10, 0x2b, 0x70, 0x7d, 0x0f, 0xe9, 0x39, 0xdf,
	0xf6, 0xfd, 0xb1, 0x63, 0x79, 0xa8, 0x6e, 0xfc, 0xd6, 0xa0, 0x65, 0x73, 0x31, 0x55, 0xca, 0xaf,
	0xa0, 0x31, 0x17, 0x59, 0x1c, 0xca, 0x62, 0xa0, 0x22, 0xc3, 0x04, 0x7a, 0x33, 0x16, 0xd3, 0x64,
	0xc9, 0x44, 0x12, 0x72, 0x26, 0xd7, 0xc5, 0x70, 0x97, 0x07, 0xc3, 0x6d, 0x85, 0x54, 0x70, 0x53,
	0x62, 0x90, 0x03, 0x05, 0xc3, 0x04, 0xfc, 0x1c, 0xa5, 0x66, 0x60, 0xc9, 0x82, 0x53, 0x54, 0xc1,
	0x47, 0xd0, 0xbe, 0x5b, 0x71, 0xc9, 0xd2, 0x30, 0x93, 0x48, 0x33, 0xfe, 0x54, 0xa1, 0x33, 0x66,
	0x92, 0x66, 0x21, 0x57, 0xcd, 0x5e, 0x43, 0x63, 0xc9, 0xe2, 0x94, 0x6f, 0xb6, 0xdf, 0x1b, 0x9e,
	0x1e, 0x6e, 0x5a, 0x15, 0x73, 0xe8, 0xa8, 0x42, 0x0a, 0xa8, 0x22, 0xa9, 0x7d, 0xaa, 0x09, 0x3a,
	0xcf, 0x49, 0x4f, 0xe7, 0x51, 0x24, 0x95, 0x61, 0x07, 0x8e, 0x23, 0xc1, 0x39, 0x8d, 0x24, 0x13,
	0xc9, 0x44, 0x1d, 0xb7, 0xa6, 0xd8, 0x67, 0x07, 0xec, 0xbd, 0xf6, 0x46, 0x15, 0xd2, 0xdb, 0x91,
	0x54, 0xc3, 0x36, 0xf4, 0xe2, 0x30, 0x9d, 0x3c, 0x86, 0x7c, 0x45, 0x37, 0x2a, 0xfa, 0x0b, 0x54,
	0xba, 0x71, 0x98, 0x7e, 0xcd, 0x29, 0x4a, 0xe3, 0x0a, 0xf4, 0x29, 0x17, 0xd3, 0x7e, 0x5d, 0x31,
	0x4f, 0xfe, 0xb3, 0xff, 0x51, 0x85, 0x28, 0x98, 0xdd, 0xd8, 0x78, 0xd1, 0x78, 0x0f, 0xc7, 0xfe,
	0x4a, 0xa6, 0x2b, 0x49, 0xe8, 0x9c, 0x66, 0x34, 0x89, 0x28, 0x3e, 0x81, 0x66, 0x22, 0x66, 0x74,
	0xc2, 0x66, 0xdb, 0x63, 0xe7, 0xa9, 0x3b, 0xc3, 0x08, 0x6a, 0x8f, 0x61, 0xa6, 0xf6, 0xd3, 0x26,
	0x79, 0x68, 0xdc, 0x42, 0xdd, 0xc9, 0x32, 0x91, 0xe1, 0xd7, 0xd0, 0x9b, 0x87, 0x8c, 0xd3, 0xd9,
	0xa4, 0x4c, 0xed, 0x6e, 0xbe, 0x7a, 0x1b, 0x81, 0x3e, 0x34, 0x63, 0xba, 0x5c, 0x86, 0x0b, 0x5a,
	0x88, 0x6c, 0xd3, 0xcb, 0x9f, 0x1a, 0xc0, 0xee, 0x2c, 0xb8, 0x05, 0xba, 0xe7, 0x7b, 0x0e, 0xaa,
	0xec, 0x5b, 0x5a, 0xdb, 0x59, 0xba, 0xba, 0x67, 0xe9, 0xda, 0xbe, 0x6d, 0xf5, 0x92, 0xbf, 0xeb,
	0x25, 0x7f, 0x37, 0x72, 0x92, 0xed, 0x7a, 0x16, 0xf9, 0x8e, 0x5a, 0x79, 0xe5, 0x9b, 0xe5, 0x06,
	0x96, 0x3d, 0x76, 0x50, 0x3b, 0x57, 0x76, 0x08, 0xf1, 0x09, 0x02, 0x43, 0x6f, 0x35, 0x51, 0xd3,
	0x1e, 0xfe, 0x78, 0xbb, 0x60, 0xf2, 0x61, 0x35, 0x1d, 0x44, 0x22, 0x36, 0xf9, 0x7a, 0x2e, 0xcd,
	0xa7, 0xd7, 0x65, 0x41, 0x13, 0x33, 0x9d, 0x5e, 0x2d, 0x84, 0x59, 0x7a, 0x70, 0xa6, 0x0d, 0xf5,
	0xd6, 0x5c, 0xff, 0x0b, 0x00, 0x00, 0xff, 0xff, 0xb8, 0xe1, 0x3e, 0x3b, 0x88, 0x04, 0x00, 0x00,
}
