// Code generated by protoc-gen-go. DO NOT EDIT.
// source: flyteidl/core/future.proto

package core // import "github.com/lyft/flyteidl/gen/pb-go/flyteidl/core"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type FutureTaskNode_Kind int32

const (
	FutureTaskNode_UNKNOWN         FutureTaskNode_Kind = 0
	FutureTaskNode_ARRAY_CONTAINER FutureTaskNode_Kind = 1
	FutureTaskNode_ARRAY_SWARM     FutureTaskNode_Kind = 2
	FutureTaskNode_HIVE            FutureTaskNode_Kind = 3
)

var FutureTaskNode_Kind_name = map[int32]string{
	0: "UNKNOWN",
	1: "ARRAY_CONTAINER",
	2: "ARRAY_SWARM",
	3: "HIVE",
}
var FutureTaskNode_Kind_value = map[string]int32{
	"UNKNOWN":         0,
	"ARRAY_CONTAINER": 1,
	"ARRAY_SWARM":     2,
	"HIVE":            3,
}

func (x FutureTaskNode_Kind) String() string {
	return proto.EnumName(FutureTaskNode_Kind_name, int32(x))
}
func (FutureTaskNode_Kind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_future_986c0d8cf780dee2, []int{1, 0}
}

// This document describes a set of tasks to execute and how the final outputs are produced.
type FutureTaskDocument struct {
	// A collection of tasks to execute.
	Tasks []*FutureTaskNode `protobuf:"bytes,1,rep,name=tasks,proto3" json:"tasks,omitempty"`
	// An absolute number of the minimum number of successful completions of subtasks. As soon as this criteria is met,
	// the future job will be marked as successful and outputs will be computed.
	MinSuccesses int64 `protobuf:"varint,2,opt,name=min_successes,json=minSuccesses,proto3" json:"min_successes,omitempty"`
	// Describes how to bind the final output of the future task from the outputs of executed nodes. The referenced ids
	// in bindings should have the generated id for the subtask.
	Outputs              []*Binding `protobuf:"bytes,3,rep,name=outputs,proto3" json:"outputs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *FutureTaskDocument) Reset()         { *m = FutureTaskDocument{} }
func (m *FutureTaskDocument) String() string { return proto.CompactTextString(m) }
func (*FutureTaskDocument) ProtoMessage()    {}
func (*FutureTaskDocument) Descriptor() ([]byte, []int) {
	return fileDescriptor_future_986c0d8cf780dee2, []int{0}
}
func (m *FutureTaskDocument) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FutureTaskDocument.Unmarshal(m, b)
}
func (m *FutureTaskDocument) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FutureTaskDocument.Marshal(b, m, deterministic)
}
func (dst *FutureTaskDocument) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FutureTaskDocument.Merge(dst, src)
}
func (m *FutureTaskDocument) XXX_Size() int {
	return xxx_messageInfo_FutureTaskDocument.Size(m)
}
func (m *FutureTaskDocument) XXX_DiscardUnknown() {
	xxx_messageInfo_FutureTaskDocument.DiscardUnknown(m)
}

var xxx_messageInfo_FutureTaskDocument proto.InternalMessageInfo

func (m *FutureTaskDocument) GetTasks() []*FutureTaskNode {
	if m != nil {
		return m.Tasks
	}
	return nil
}

func (m *FutureTaskDocument) GetMinSuccesses() int64 {
	if m != nil {
		return m.MinSuccesses
	}
	return 0
}

func (m *FutureTaskDocument) GetOutputs() []*Binding {
	if m != nil {
		return m.Outputs
	}
	return nil
}

type FutureTaskNode struct {
	// A unique identifier prefix within the document. This is used to generate unique ids for each of the tasks in
	// target. The generated ids have this format: <generate_id>:<n> where n starts with 0 and monotonically increases.
	// e.g. if generate_id is set to "my_array_job", the first task in the array job will have the id "my_array_job:0",
	// then "my_array_job:1"... etc.
	GenerateId string `protobuf:"bytes,1,opt,name=generate_id,json=generateId,proto3" json:"generate_id,omitempty"`
	// A required field to describe the type of the future task. This is used to customize the behavior of various
	// executors that can handle this type of task.
	Kind FutureTaskNode_Kind `protobuf:"varint,2,opt,name=kind,proto3,enum=flyteidl.core.FutureTaskNode_Kind" json:"kind,omitempty"`
	// The executable target of the node.
	//
	// Types that are valid to be assigned to Target:
	//	*FutureTaskNode_Array
	//	*FutureTaskNode_HiveQueries
	Target               isFutureTaskNode_Target `protobuf_oneof:"target"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *FutureTaskNode) Reset()         { *m = FutureTaskNode{} }
func (m *FutureTaskNode) String() string { return proto.CompactTextString(m) }
func (*FutureTaskNode) ProtoMessage()    {}
func (*FutureTaskNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_future_986c0d8cf780dee2, []int{1}
}
func (m *FutureTaskNode) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FutureTaskNode.Unmarshal(m, b)
}
func (m *FutureTaskNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FutureTaskNode.Marshal(b, m, deterministic)
}
func (dst *FutureTaskNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FutureTaskNode.Merge(dst, src)
}
func (m *FutureTaskNode) XXX_Size() int {
	return xxx_messageInfo_FutureTaskNode.Size(m)
}
func (m *FutureTaskNode) XXX_DiscardUnknown() {
	xxx_messageInfo_FutureTaskNode.DiscardUnknown(m)
}

var xxx_messageInfo_FutureTaskNode proto.InternalMessageInfo

func (m *FutureTaskNode) GetGenerateId() string {
	if m != nil {
		return m.GenerateId
	}
	return ""
}

func (m *FutureTaskNode) GetKind() FutureTaskNode_Kind {
	if m != nil {
		return m.Kind
	}
	return FutureTaskNode_UNKNOWN
}

type isFutureTaskNode_Target interface {
	isFutureTaskNode_Target()
}

type FutureTaskNode_Array struct {
	Array *ArrayJob `protobuf:"bytes,3,opt,name=array,proto3,oneof"`
}

type FutureTaskNode_HiveQueries struct {
	HiveQueries *HiveQueryCollection `protobuf:"bytes,4,opt,name=hive_queries,json=hiveQueries,proto3,oneof"`
}

func (*FutureTaskNode_Array) isFutureTaskNode_Target() {}

func (*FutureTaskNode_HiveQueries) isFutureTaskNode_Target() {}

func (m *FutureTaskNode) GetTarget() isFutureTaskNode_Target {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *FutureTaskNode) GetArray() *ArrayJob {
	if x, ok := m.GetTarget().(*FutureTaskNode_Array); ok {
		return x.Array
	}
	return nil
}

func (m *FutureTaskNode) GetHiveQueries() *HiveQueryCollection {
	if x, ok := m.GetTarget().(*FutureTaskNode_HiveQueries); ok {
		return x.HiveQueries
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FutureTaskNode) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FutureTaskNode_OneofMarshaler, _FutureTaskNode_OneofUnmarshaler, _FutureTaskNode_OneofSizer, []interface{}{
		(*FutureTaskNode_Array)(nil),
		(*FutureTaskNode_HiveQueries)(nil),
	}
}

func _FutureTaskNode_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FutureTaskNode)
	// target
	switch x := m.Target.(type) {
	case *FutureTaskNode_Array:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Array); err != nil {
			return err
		}
	case *FutureTaskNode_HiveQueries:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HiveQueries); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("FutureTaskNode.Target has unexpected type %T", x)
	}
	return nil
}

func _FutureTaskNode_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FutureTaskNode)
	switch tag {
	case 3: // target.array
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ArrayJob)
		err := b.DecodeMessage(msg)
		m.Target = &FutureTaskNode_Array{msg}
		return true, err
	case 4: // target.hive_queries
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HiveQueryCollection)
		err := b.DecodeMessage(msg)
		m.Target = &FutureTaskNode_HiveQueries{msg}
		return true, err
	default:
		return false, nil
	}
}

func _FutureTaskNode_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FutureTaskNode)
	// target
	switch x := m.Target.(type) {
	case *FutureTaskNode_Array:
		s := proto.Size(x.Array)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FutureTaskNode_HiveQueries:
		s := proto.Size(x.HiveQueries)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Defines a query to execute on a hive cluster.
type HiveQuery struct {
	// The query string.
	Query string `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	// Metadata to use when executing the query. Not all fields can be used with all execution engines.
	Metadata             *TaskMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *HiveQuery) Reset()         { *m = HiveQuery{} }
func (m *HiveQuery) String() string { return proto.CompactTextString(m) }
func (*HiveQuery) ProtoMessage()    {}
func (*HiveQuery) Descriptor() ([]byte, []int) {
	return fileDescriptor_future_986c0d8cf780dee2, []int{2}
}
func (m *HiveQuery) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HiveQuery.Unmarshal(m, b)
}
func (m *HiveQuery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HiveQuery.Marshal(b, m, deterministic)
}
func (dst *HiveQuery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HiveQuery.Merge(dst, src)
}
func (m *HiveQuery) XXX_Size() int {
	return xxx_messageInfo_HiveQuery.Size(m)
}
func (m *HiveQuery) XXX_DiscardUnknown() {
	xxx_messageInfo_HiveQuery.DiscardUnknown(m)
}

var xxx_messageInfo_HiveQuery proto.InternalMessageInfo

func (m *HiveQuery) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *HiveQuery) GetMetadata() *TaskMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// Defines a collection of hive queries.
type HiveQueryCollection struct {
	Queries              []*HiveQuery `protobuf:"bytes,2,rep,name=queries,proto3" json:"queries,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *HiveQueryCollection) Reset()         { *m = HiveQueryCollection{} }
func (m *HiveQueryCollection) String() string { return proto.CompactTextString(m) }
func (*HiveQueryCollection) ProtoMessage()    {}
func (*HiveQueryCollection) Descriptor() ([]byte, []int) {
	return fileDescriptor_future_986c0d8cf780dee2, []int{3}
}
func (m *HiveQueryCollection) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HiveQueryCollection.Unmarshal(m, b)
}
func (m *HiveQueryCollection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HiveQueryCollection.Marshal(b, m, deterministic)
}
func (dst *HiveQueryCollection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HiveQueryCollection.Merge(dst, src)
}
func (m *HiveQueryCollection) XXX_Size() int {
	return xxx_messageInfo_HiveQueryCollection.Size(m)
}
func (m *HiveQueryCollection) XXX_DiscardUnknown() {
	xxx_messageInfo_HiveQueryCollection.DiscardUnknown(m)
}

var xxx_messageInfo_HiveQueryCollection proto.InternalMessageInfo

func (m *HiveQueryCollection) GetQueries() []*HiveQuery {
	if m != nil {
		return m.Queries
	}
	return nil
}

// Defines a collection of containers to execute.
type SwarmDefinition struct {
	// Metadata about the task.
	Metadata *TaskMetadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// The primary container of a swarm job. This container starts after all the init_containers have successfully
	// completed. The end-state of the primary container determines the overall state of the swarm task.
	PrimaryContainer *Container `protobuf:"bytes,2,opt,name=primary_container,json=primaryContainer,proto3" json:"primary_container,omitempty"`
	// List of initialization containers belonging to the pod.
	// Init containers are executed in order prior to containers being started. If any
	// init container fails, the pod is considered to have failed and is handled according
	// to its restartPolicy. The name for an init container or normal container must be
	// unique among all containers.
	// Init containers may not have Lifecycle actions, Readiness probes, or Liveness probes.
	// The resourceRequirements of an init container are taken into account during scheduling
	// by finding the highest request/limit for each resource type, and then using the max of
	// of that value or the sum of the normal containers. Limits are applied to init containers
	// in a similar fashion.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
	InitContainers []*Container `protobuf:"bytes,3,rep,name=init_containers,json=initContainers,proto3" json:"init_containers,omitempty"`
	// List of containers that get started after all init_containers have successfully completed. The end-state of
	// sidecar_containers is ignored when computing the overall state of the swarm task.
	SidecarContainers    []*Container `protobuf:"bytes,4,rep,name=sidecar_containers,json=sidecarContainers,proto3" json:"sidecar_containers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *SwarmDefinition) Reset()         { *m = SwarmDefinition{} }
func (m *SwarmDefinition) String() string { return proto.CompactTextString(m) }
func (*SwarmDefinition) ProtoMessage()    {}
func (*SwarmDefinition) Descriptor() ([]byte, []int) {
	return fileDescriptor_future_986c0d8cf780dee2, []int{4}
}
func (m *SwarmDefinition) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SwarmDefinition.Unmarshal(m, b)
}
func (m *SwarmDefinition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SwarmDefinition.Marshal(b, m, deterministic)
}
func (dst *SwarmDefinition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwarmDefinition.Merge(dst, src)
}
func (m *SwarmDefinition) XXX_Size() int {
	return xxx_messageInfo_SwarmDefinition.Size(m)
}
func (m *SwarmDefinition) XXX_DiscardUnknown() {
	xxx_messageInfo_SwarmDefinition.DiscardUnknown(m)
}

var xxx_messageInfo_SwarmDefinition proto.InternalMessageInfo

func (m *SwarmDefinition) GetMetadata() *TaskMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *SwarmDefinition) GetPrimaryContainer() *Container {
	if m != nil {
		return m.PrimaryContainer
	}
	return nil
}

func (m *SwarmDefinition) GetInitContainers() []*Container {
	if m != nil {
		return m.InitContainers
	}
	return nil
}

func (m *SwarmDefinition) GetSidecarContainers() []*Container {
	if m != nil {
		return m.SidecarContainers
	}
	return nil
}

// Describes a job that can process independent pieces of data concurrently. Multiple copies of the runnable component
// will be executed concurrently.
type ArrayJob struct {
	// Defines the maximum number of instances to bring up concurrently at any given point. If not specified, the system
	// will attempt to execute as many instances in parallel as possible.
	Slots int64 `protobuf:"varint,1,opt,name=slots,proto3" json:"slots,omitempty"`
	// Defines the number of successful completions needed to mark the job as success. This number should match
	// the size of the input if the job requires processing of all input data.
	Completions int64 `protobuf:"varint,2,opt,name=completions,proto3" json:"completions,omitempty"`
	// Types that are valid to be assigned to Runnable:
	//	*ArrayJob_Task
	//	*ArrayJob_Swarm
	Runnable isArrayJob_Runnable `protobuf_oneof:"runnable"`
	// The location for where the input will be. The usage of this location is engine-dependent.
	// AWS_Batch & K8s_Batch: This location will be passed in to each task in the array job. Each job is responsible for
	// processing only the portion of the input it's meant to based on an environment variable passed into the container
	// . The algorithm for figuring that out is as follows:
	// - Read environment variable: BATCH_JOB_ARRAY_INDEX_VAR_NAME if it exists, this will contain the name of another
	//   environment variable that actually contain the index (e.g. AWS_BATCH_JOB_ARRAY_INDEX for AWS batch).
	// - Read environment variable: BATCH_JOB_ARRAY_INDEX_OFFSET if it exists, this will contain an offset to add to the
	//   index obtained above.
	// - The input location is then: <input_ref>/<final_index>/inputs.pb
	// For example, in AWS_Batch, BATCH_JOB_ARRAY_INDEX_VAR_NAME will be set to AWS_BATCH_JOB_ARRAY_INDEX. The job can
	// then look at AWS_BATCH_JOB_ARRAY_INDEX to know the index of the job (e.g. 5), then let's say BATCH_JOB_ARRAY_INDEX_OFFSET
	// contains the value 2. The final output location is then: <input_ref>/7/inputs.pb
	// P.S for Azure: The execution engine will have to process the input and slice it for each task. It'll then pass an
	// absolute location to each task for where it can find its input.
	InputRef             string   `protobuf:"bytes,5,opt,name=input_ref,json=inputRef,proto3" json:"input_ref,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArrayJob) Reset()         { *m = ArrayJob{} }
func (m *ArrayJob) String() string { return proto.CompactTextString(m) }
func (*ArrayJob) ProtoMessage()    {}
func (*ArrayJob) Descriptor() ([]byte, []int) {
	return fileDescriptor_future_986c0d8cf780dee2, []int{5}
}
func (m *ArrayJob) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ArrayJob.Unmarshal(m, b)
}
func (m *ArrayJob) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ArrayJob.Marshal(b, m, deterministic)
}
func (dst *ArrayJob) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArrayJob.Merge(dst, src)
}
func (m *ArrayJob) XXX_Size() int {
	return xxx_messageInfo_ArrayJob.Size(m)
}
func (m *ArrayJob) XXX_DiscardUnknown() {
	xxx_messageInfo_ArrayJob.DiscardUnknown(m)
}

var xxx_messageInfo_ArrayJob proto.InternalMessageInfo

func (m *ArrayJob) GetSlots() int64 {
	if m != nil {
		return m.Slots
	}
	return 0
}

func (m *ArrayJob) GetCompletions() int64 {
	if m != nil {
		return m.Completions
	}
	return 0
}

type isArrayJob_Runnable interface {
	isArrayJob_Runnable()
}

type ArrayJob_Task struct {
	Task *TaskTemplate `protobuf:"bytes,3,opt,name=task,proto3,oneof"`
}

type ArrayJob_Swarm struct {
	Swarm *SwarmDefinition `protobuf:"bytes,4,opt,name=swarm,proto3,oneof"`
}

func (*ArrayJob_Task) isArrayJob_Runnable() {}

func (*ArrayJob_Swarm) isArrayJob_Runnable() {}

func (m *ArrayJob) GetRunnable() isArrayJob_Runnable {
	if m != nil {
		return m.Runnable
	}
	return nil
}

func (m *ArrayJob) GetTask() *TaskTemplate {
	if x, ok := m.GetRunnable().(*ArrayJob_Task); ok {
		return x.Task
	}
	return nil
}

func (m *ArrayJob) GetSwarm() *SwarmDefinition {
	if x, ok := m.GetRunnable().(*ArrayJob_Swarm); ok {
		return x.Swarm
	}
	return nil
}

func (m *ArrayJob) GetInputRef() string {
	if m != nil {
		return m.InputRef
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ArrayJob) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ArrayJob_OneofMarshaler, _ArrayJob_OneofUnmarshaler, _ArrayJob_OneofSizer, []interface{}{
		(*ArrayJob_Task)(nil),
		(*ArrayJob_Swarm)(nil),
	}
}

func _ArrayJob_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ArrayJob)
	// runnable
	switch x := m.Runnable.(type) {
	case *ArrayJob_Task:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Task); err != nil {
			return err
		}
	case *ArrayJob_Swarm:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Swarm); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ArrayJob.Runnable has unexpected type %T", x)
	}
	return nil
}

func _ArrayJob_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ArrayJob)
	switch tag {
	case 3: // runnable.task
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TaskTemplate)
		err := b.DecodeMessage(msg)
		m.Runnable = &ArrayJob_Task{msg}
		return true, err
	case 4: // runnable.swarm
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SwarmDefinition)
		err := b.DecodeMessage(msg)
		m.Runnable = &ArrayJob_Swarm{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ArrayJob_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ArrayJob)
	// runnable
	switch x := m.Runnable.(type) {
	case *ArrayJob_Task:
		s := proto.Size(x.Task)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ArrayJob_Swarm:
		s := proto.Size(x.Swarm)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*FutureTaskDocument)(nil), "flyteidl.core.FutureTaskDocument")
	proto.RegisterType((*FutureTaskNode)(nil), "flyteidl.core.FutureTaskNode")
	proto.RegisterType((*HiveQuery)(nil), "flyteidl.core.HiveQuery")
	proto.RegisterType((*HiveQueryCollection)(nil), "flyteidl.core.HiveQueryCollection")
	proto.RegisterType((*SwarmDefinition)(nil), "flyteidl.core.SwarmDefinition")
	proto.RegisterType((*ArrayJob)(nil), "flyteidl.core.ArrayJob")
	proto.RegisterEnum("flyteidl.core.FutureTaskNode_Kind", FutureTaskNode_Kind_name, FutureTaskNode_Kind_value)
}

func init() { proto.RegisterFile("flyteidl/core/future.proto", fileDescriptor_future_986c0d8cf780dee2) }

var fileDescriptor_future_986c0d8cf780dee2 = []byte{
	// 658 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0xdd, 0x4e, 0xdb, 0x4a,
	0x10, 0x8e, 0xf3, 0x03, 0x61, 0x0c, 0x24, 0x2c, 0x47, 0xe7, 0xf8, 0xc0, 0xf9, 0x89, 0xdc, 0x9b,
	0xdc, 0x34, 0xa1, 0x41, 0xa2, 0xd7, 0x49, 0xa0, 0x24, 0x45, 0x04, 0x75, 0xa1, 0x45, 0xe5, 0x26,
	0xda, 0xd8, 0x93, 0xb0, 0xc2, 0x5e, 0xa7, 0xbb, 0x6b, 0xaa, 0x3c, 0x4c, 0xa5, 0x3e, 0x43, 0x1f,
	0xa6, 0xcf, 0x53, 0x79, 0x63, 0x07, 0x12, 0x41, 0xab, 0x5e, 0xee, 0xcc, 0x37, 0xdf, 0x7c, 0xfb,
	0xcd, 0xec, 0xc2, 0xde, 0x38, 0x98, 0x69, 0xe4, 0x7e, 0xd0, 0xf4, 0x22, 0x89, 0xcd, 0x71, 0xac,
	0x63, 0x89, 0x8d, 0xa9, 0x8c, 0x74, 0x44, 0xb6, 0xb2, 0x5c, 0x23, 0xc9, 0xed, 0xfd, 0xbd, 0x0c,
	0xd5, 0x4c, 0xdd, 0xa9, 0x39, 0x72, 0xef, 0x9f, 0xe5, 0x54, 0xc0, 0x35, 0x4a, 0x16, 0xa4, 0x59,
	0xf7, 0xab, 0x05, 0xe4, 0x8d, 0x21, 0xbe, 0x62, 0xea, 0xee, 0x38, 0xf2, 0xe2, 0x10, 0x85, 0x26,
	0x87, 0x50, 0x32, 0x1c, 0x8e, 0x55, 0x2b, 0xd4, 0xed, 0xd6, 0xbf, 0x8d, 0xa5, 0x76, 0x8d, 0x87,
	0x8a, 0x41, 0xe4, 0x23, 0x9d, 0x63, 0xc9, 0x0b, 0xd8, 0x0a, 0xb9, 0x18, 0xaa, 0xd8, 0xf3, 0x50,
	0x29, 0x54, 0x4e, 0xbe, 0x66, 0xd5, 0x0b, 0x74, 0x33, 0xe4, 0xe2, 0x32, 0x8b, 0x91, 0x03, 0x58,
	0x8f, 0x62, 0x3d, 0x8d, 0xb5, 0x72, 0x0a, 0x86, 0xfb, 0xcf, 0x15, 0xee, 0x0e, 0x17, 0x3e, 0x17,
	0x13, 0x9a, 0xc1, 0xdc, 0x6f, 0x79, 0xd8, 0x5e, 0x6e, 0x48, 0xfe, 0x07, 0x7b, 0x82, 0x02, 0x25,
	0xd3, 0x38, 0xe4, 0xbe, 0x63, 0xd5, 0xac, 0xfa, 0x06, 0x85, 0x2c, 0xd4, 0xf7, 0xc9, 0x11, 0x14,
	0xef, 0xb8, 0xf0, 0x8d, 0x82, 0xed, 0x96, 0xfb, 0x53, 0xf9, 0x8d, 0x33, 0x2e, 0x7c, 0x6a, 0xf0,
	0xa4, 0x09, 0x25, 0x26, 0x25, 0x9b, 0x39, 0x85, 0x9a, 0x55, 0xb7, 0x5b, 0x7f, 0xad, 0x14, 0xb6,
	0x93, 0xdc, 0xdb, 0x68, 0xd4, 0xcb, 0xd1, 0x39, 0x8e, 0x9c, 0xc2, 0xe6, 0x2d, 0xbf, 0xc7, 0xe1,
	0xa7, 0x18, 0x25, 0x47, 0xe5, 0x14, 0x4d, 0xdd, 0x6a, 0xc3, 0x1e, 0xbf, 0xc7, 0x77, 0x31, 0xca,
	0x59, 0x37, 0x0a, 0x02, 0xf4, 0x34, 0x8f, 0x44, 0x2f, 0x47, 0xed, 0xdb, 0x34, 0xcc, 0x51, 0xb9,
	0x5d, 0x28, 0x26, 0x3a, 0x88, 0x0d, 0xeb, 0xef, 0x07, 0x67, 0x83, 0x8b, 0xeb, 0x41, 0x35, 0x47,
	0x76, 0xa1, 0xd2, 0xa6, 0xb4, 0xfd, 0x71, 0xd8, 0xbd, 0x18, 0x5c, 0xb5, 0xfb, 0x83, 0x13, 0x5a,
	0xb5, 0x48, 0x05, 0xec, 0x79, 0xf0, 0xf2, 0xba, 0x4d, 0xcf, 0xab, 0x79, 0x52, 0x86, 0x62, 0xaf,
	0xff, 0xe1, 0xa4, 0x5a, 0xe8, 0x94, 0x61, 0x4d, 0x33, 0x39, 0x41, 0xed, 0xde, 0xc0, 0xc6, 0xa2,
	0x29, 0xf9, 0x03, 0x4a, 0x89, 0xbe, 0x59, 0x6a, 0xd4, 0xfc, 0x40, 0x5e, 0x43, 0x39, 0x44, 0xcd,
	0x7c, 0xa6, 0x99, 0xf1, 0xc9, 0x6e, 0xed, 0xaf, 0xc8, 0x4e, 0x1c, 0x3a, 0x4f, 0x21, 0x74, 0x01,
	0x76, 0xfb, 0xb0, 0xfb, 0xc4, 0x85, 0x48, 0x0b, 0xd6, 0x33, 0x17, 0xf2, 0x66, 0xb2, 0xce, 0x73,
	0x2e, 0xd0, 0x0c, 0xe8, 0x7e, 0xc9, 0x43, 0xe5, 0xf2, 0x33, 0x93, 0xe1, 0x31, 0x8e, 0xb9, 0xe0,
	0x86, 0xe7, 0xb1, 0x2e, 0xeb, 0x37, 0x74, 0x91, 0x13, 0xd8, 0x99, 0x4a, 0x1e, 0x32, 0x39, 0x1b,
	0x7a, 0x91, 0xd0, 0x8c, 0x0b, 0x94, 0xe9, 0xcd, 0x56, 0xa5, 0x74, 0xb3, 0x3c, 0xad, 0xa6, 0x25,
	0x8b, 0x08, 0x69, 0x43, 0x25, 0x91, 0xf2, 0xc0, 0x91, 0x6d, 0xea, 0xf3, 0x24, 0xdb, 0x49, 0xc1,
	0xe2, 0xa8, 0xc8, 0x29, 0x10, 0xc5, 0x7d, 0xf4, 0x98, 0x7c, 0xcc, 0x52, 0xfc, 0x05, 0xcb, 0x4e,
	0x5a, 0xf3, 0x40, 0xe4, 0x7e, 0xb7, 0xa0, 0x9c, 0x2d, 0x5d, 0x32, 0x46, 0x15, 0x44, 0x5a, 0x19,
	0x57, 0x0a, 0x74, 0x7e, 0x20, 0x35, 0xb0, 0xbd, 0x28, 0x9c, 0x06, 0x98, 0x98, 0x97, 0xbd, 0xb9,
	0xc7, 0x21, 0xf2, 0x0a, 0x8a, 0xc9, 0x03, 0x4d, 0x77, 0xfa, 0x29, 0x33, 0xaf, 0x30, 0x9c, 0x06,
	0x4c, 0x63, 0x2f, 0x47, 0x0d, 0x94, 0x1c, 0x41, 0x49, 0x25, 0x63, 0x49, 0xf7, 0xf9, 0xbf, 0x95,
	0x9a, 0x95, 0x91, 0x25, 0xcf, 0xc1, 0xc0, 0xc9, 0x3e, 0x6c, 0x70, 0x31, 0x8d, 0xf5, 0x50, 0xe2,
	0xd8, 0x29, 0x99, 0x6d, 0x2b, 0x9b, 0x00, 0xc5, 0x71, 0x07, 0xa0, 0x2c, 0x63, 0x21, 0xd8, 0x28,
	0xc0, 0x4e, 0xeb, 0xe6, 0x60, 0xc2, 0xf5, 0x6d, 0x3c, 0x6a, 0x78, 0x51, 0xd8, 0x0c, 0x66, 0x63,
	0xdd, 0x5c, 0xfc, 0x53, 0x13, 0x14, 0xcd, 0xe9, 0xe8, 0xe5, 0x24, 0x6a, 0x2e, 0x7d, 0x5d, 0xa3,
	0x35, 0xf3, 0x65, 0x1d, 0xfe, 0x08, 0x00, 0x00, 0xff, 0xff, 0x64, 0xa1, 0x8d, 0x94, 0x18, 0x05,
	0x00, 0x00,
}
