// Code generated by protoc-gen-go. DO NOT EDIT.
// source: core/types.proto

package core

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Define a set of simple types.
type SimpleType int32

const (
	SimpleType_NONE      SimpleType = 0
	SimpleType_INTEGER   SimpleType = 1
	SimpleType_FLOAT     SimpleType = 2
	SimpleType_STRING    SimpleType = 3
	SimpleType_BOOLEAN   SimpleType = 4
	SimpleType_DATE_TIME SimpleType = 5
	SimpleType_DURATION  SimpleType = 6
	SimpleType_BLOB      SimpleType = 7
	SimpleType_BINARY    SimpleType = 8
	SimpleType_WAITABLE  SimpleType = 9
	SimpleType_ERROR     SimpleType = 10
)

var SimpleType_name = map[int32]string{
	0:  "NONE",
	1:  "INTEGER",
	2:  "FLOAT",
	3:  "STRING",
	4:  "BOOLEAN",
	5:  "DATE_TIME",
	6:  "DURATION",
	7:  "BLOB",
	8:  "BINARY",
	9:  "WAITABLE",
	10: "ERROR",
}
var SimpleType_value = map[string]int32{
	"NONE":      0,
	"INTEGER":   1,
	"FLOAT":     2,
	"STRING":    3,
	"BOOLEAN":   4,
	"DATE_TIME": 5,
	"DURATION":  6,
	"BLOB":      7,
	"BINARY":    8,
	"WAITABLE":  9,
	"ERROR":     10,
}

func (x SimpleType) String() string {
	return proto.EnumName(SimpleType_name, int32(x))
}
func (SimpleType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_types_98913e853d6ccda5, []int{0}
}

type SchemaType_SchemaColumn_SchemaColumnType int32

const (
	SchemaType_SchemaColumn_INTEGER  SchemaType_SchemaColumn_SchemaColumnType = 0
	SchemaType_SchemaColumn_FLOAT    SchemaType_SchemaColumn_SchemaColumnType = 1
	SchemaType_SchemaColumn_STRING   SchemaType_SchemaColumn_SchemaColumnType = 2
	SchemaType_SchemaColumn_DATETIME SchemaType_SchemaColumn_SchemaColumnType = 3
	SchemaType_SchemaColumn_DURATION SchemaType_SchemaColumn_SchemaColumnType = 4
	SchemaType_SchemaColumn_BOOLEAN  SchemaType_SchemaColumn_SchemaColumnType = 5
)

var SchemaType_SchemaColumn_SchemaColumnType_name = map[int32]string{
	0: "INTEGER",
	1: "FLOAT",
	2: "STRING",
	3: "DATETIME",
	4: "DURATION",
	5: "BOOLEAN",
}
var SchemaType_SchemaColumn_SchemaColumnType_value = map[string]int32{
	"INTEGER":  0,
	"FLOAT":    1,
	"STRING":   2,
	"DATETIME": 3,
	"DURATION": 4,
	"BOOLEAN":  5,
}

func (x SchemaType_SchemaColumn_SchemaColumnType) String() string {
	return proto.EnumName(SchemaType_SchemaColumn_SchemaColumnType_name, int32(x))
}
func (SchemaType_SchemaColumn_SchemaColumnType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_types_98913e853d6ccda5, []int{0, 0, 0}
}

// Defines schema columns and types to strongly type-validate schemas interoperability.
type SchemaType struct {
	// A list of ordered columns this schema comprises of.
	Columns              []*SchemaType_SchemaColumn `protobuf:"bytes,3,rep,name=columns" json:"columns,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *SchemaType) Reset()         { *m = SchemaType{} }
func (m *SchemaType) String() string { return proto.CompactTextString(m) }
func (*SchemaType) ProtoMessage()    {}
func (*SchemaType) Descriptor() ([]byte, []int) {
	return fileDescriptor_types_98913e853d6ccda5, []int{0}
}
func (m *SchemaType) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SchemaType.Unmarshal(m, b)
}
func (m *SchemaType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SchemaType.Marshal(b, m, deterministic)
}
func (dst *SchemaType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaType.Merge(dst, src)
}
func (m *SchemaType) XXX_Size() int {
	return xxx_messageInfo_SchemaType.Size(m)
}
func (m *SchemaType) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaType.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaType proto.InternalMessageInfo

func (m *SchemaType) GetColumns() []*SchemaType_SchemaColumn {
	if m != nil {
		return m.Columns
	}
	return nil
}

type SchemaType_SchemaColumn struct {
	// A unique name -within the schema type- for the column
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The column type. This allows a limited set of types currently.
	Type                 SchemaType_SchemaColumn_SchemaColumnType `protobuf:"varint,2,opt,name=type,enum=core.SchemaType_SchemaColumn_SchemaColumnType" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                 `json:"-"`
	XXX_unrecognized     []byte                                   `json:"-"`
	XXX_sizecache        int32                                    `json:"-"`
}

func (m *SchemaType_SchemaColumn) Reset()         { *m = SchemaType_SchemaColumn{} }
func (m *SchemaType_SchemaColumn) String() string { return proto.CompactTextString(m) }
func (*SchemaType_SchemaColumn) ProtoMessage()    {}
func (*SchemaType_SchemaColumn) Descriptor() ([]byte, []int) {
	return fileDescriptor_types_98913e853d6ccda5, []int{0, 0}
}
func (m *SchemaType_SchemaColumn) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SchemaType_SchemaColumn.Unmarshal(m, b)
}
func (m *SchemaType_SchemaColumn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SchemaType_SchemaColumn.Marshal(b, m, deterministic)
}
func (dst *SchemaType_SchemaColumn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaType_SchemaColumn.Merge(dst, src)
}
func (m *SchemaType_SchemaColumn) XXX_Size() int {
	return xxx_messageInfo_SchemaType_SchemaColumn.Size(m)
}
func (m *SchemaType_SchemaColumn) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaType_SchemaColumn.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaType_SchemaColumn proto.InternalMessageInfo

func (m *SchemaType_SchemaColumn) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SchemaType_SchemaColumn) GetType() SchemaType_SchemaColumn_SchemaColumnType {
	if m != nil {
		return m.Type
	}
	return SchemaType_SchemaColumn_INTEGER
}

// Defines a strong type to allow type checking between interfaces.
type LiteralType struct {
	// Types that are valid to be assigned to Type:
	//	*LiteralType_Simple
	//	*LiteralType_Schema
	//	*LiteralType_CollectionType
	//	*LiteralType_MapValueType
	Type                 isLiteralType_Type `protobuf_oneof:"type"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *LiteralType) Reset()         { *m = LiteralType{} }
func (m *LiteralType) String() string { return proto.CompactTextString(m) }
func (*LiteralType) ProtoMessage()    {}
func (*LiteralType) Descriptor() ([]byte, []int) {
	return fileDescriptor_types_98913e853d6ccda5, []int{1}
}
func (m *LiteralType) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LiteralType.Unmarshal(m, b)
}
func (m *LiteralType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LiteralType.Marshal(b, m, deterministic)
}
func (dst *LiteralType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiteralType.Merge(dst, src)
}
func (m *LiteralType) XXX_Size() int {
	return xxx_messageInfo_LiteralType.Size(m)
}
func (m *LiteralType) XXX_DiscardUnknown() {
	xxx_messageInfo_LiteralType.DiscardUnknown(m)
}

var xxx_messageInfo_LiteralType proto.InternalMessageInfo

type isLiteralType_Type interface {
	isLiteralType_Type()
}

type LiteralType_Simple struct {
	Simple SimpleType `protobuf:"varint,1,opt,name=simple,enum=core.SimpleType,oneof"`
}
type LiteralType_Schema struct {
	Schema *SchemaType `protobuf:"bytes,2,opt,name=schema,oneof"`
}
type LiteralType_CollectionType struct {
	CollectionType *LiteralType `protobuf:"bytes,3,opt,name=collection_type,json=collectionType,oneof"`
}
type LiteralType_MapValueType struct {
	MapValueType *LiteralType `protobuf:"bytes,4,opt,name=map_value_type,json=mapValueType,oneof"`
}

func (*LiteralType_Simple) isLiteralType_Type()         {}
func (*LiteralType_Schema) isLiteralType_Type()         {}
func (*LiteralType_CollectionType) isLiteralType_Type() {}
func (*LiteralType_MapValueType) isLiteralType_Type()   {}

func (m *LiteralType) GetType() isLiteralType_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *LiteralType) GetSimple() SimpleType {
	if x, ok := m.GetType().(*LiteralType_Simple); ok {
		return x.Simple
	}
	return SimpleType_NONE
}

func (m *LiteralType) GetSchema() *SchemaType {
	if x, ok := m.GetType().(*LiteralType_Schema); ok {
		return x.Schema
	}
	return nil
}

func (m *LiteralType) GetCollectionType() *LiteralType {
	if x, ok := m.GetType().(*LiteralType_CollectionType); ok {
		return x.CollectionType
	}
	return nil
}

func (m *LiteralType) GetMapValueType() *LiteralType {
	if x, ok := m.GetType().(*LiteralType_MapValueType); ok {
		return x.MapValueType
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*LiteralType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _LiteralType_OneofMarshaler, _LiteralType_OneofUnmarshaler, _LiteralType_OneofSizer, []interface{}{
		(*LiteralType_Simple)(nil),
		(*LiteralType_Schema)(nil),
		(*LiteralType_CollectionType)(nil),
		(*LiteralType_MapValueType)(nil),
	}
}

func _LiteralType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*LiteralType)
	// type
	switch x := m.Type.(type) {
	case *LiteralType_Simple:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Simple))
	case *LiteralType_Schema:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Schema); err != nil {
			return err
		}
	case *LiteralType_CollectionType:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CollectionType); err != nil {
			return err
		}
	case *LiteralType_MapValueType:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MapValueType); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("LiteralType.Type has unexpected type %T", x)
	}
	return nil
}

func _LiteralType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*LiteralType)
	switch tag {
	case 1: // type.simple
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &LiteralType_Simple{SimpleType(x)}
		return true, err
	case 2: // type.schema
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SchemaType)
		err := b.DecodeMessage(msg)
		m.Type = &LiteralType_Schema{msg}
		return true, err
	case 3: // type.collection_type
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LiteralType)
		err := b.DecodeMessage(msg)
		m.Type = &LiteralType_CollectionType{msg}
		return true, err
	case 4: // type.map_value_type
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LiteralType)
		err := b.DecodeMessage(msg)
		m.Type = &LiteralType_MapValueType{msg}
		return true, err
	default:
		return false, nil
	}
}

func _LiteralType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*LiteralType)
	// type
	switch x := m.Type.(type) {
	case *LiteralType_Simple:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.Simple))
	case *LiteralType_Schema:
		s := proto.Size(x.Schema)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LiteralType_CollectionType:
		s := proto.Size(x.CollectionType)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LiteralType_MapValueType:
		s := proto.Size(x.MapValueType)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A reference to an output produced by a node. The type can be retrieved -and validated- from
// the underlying interface of the node.
type OutputReference struct {
	// Node id must exist at the graph layer.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId" json:"node_id,omitempty"`
	// Variable name must refer to an output variable for the node.
	Var                  string   `protobuf:"bytes,2,opt,name=var" json:"var,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OutputReference) Reset()         { *m = OutputReference{} }
func (m *OutputReference) String() string { return proto.CompactTextString(m) }
func (*OutputReference) ProtoMessage()    {}
func (*OutputReference) Descriptor() ([]byte, []int) {
	return fileDescriptor_types_98913e853d6ccda5, []int{2}
}
func (m *OutputReference) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OutputReference.Unmarshal(m, b)
}
func (m *OutputReference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OutputReference.Marshal(b, m, deterministic)
}
func (dst *OutputReference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputReference.Merge(dst, src)
}
func (m *OutputReference) XXX_Size() int {
	return xxx_messageInfo_OutputReference.Size(m)
}
func (m *OutputReference) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputReference.DiscardUnknown(m)
}

var xxx_messageInfo_OutputReference proto.InternalMessageInfo

func (m *OutputReference) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

func (m *OutputReference) GetVar() string {
	if m != nil {
		return m.Var
	}
	return ""
}

// Represents an error thrown from a node.
type Error struct {
	// The node id that threw the error.
	FailedNodeId string `protobuf:"bytes,1,opt,name=failed_node_id,json=failedNodeId" json:"failed_node_id,omitempty"`
	// Error message thrown.
	Message              string   `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Error) Reset()         { *m = Error{} }
func (m *Error) String() string { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()    {}
func (*Error) Descriptor() ([]byte, []int) {
	return fileDescriptor_types_98913e853d6ccda5, []int{3}
}
func (m *Error) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Error.Unmarshal(m, b)
}
func (m *Error) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Error.Marshal(b, m, deterministic)
}
func (dst *Error) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Error.Merge(dst, src)
}
func (m *Error) XXX_Size() int {
	return xxx_messageInfo_Error.Size(m)
}
func (m *Error) XXX_DiscardUnknown() {
	xxx_messageInfo_Error.DiscardUnknown(m)
}

var xxx_messageInfo_Error proto.InternalMessageInfo

func (m *Error) GetFailedNodeId() string {
	if m != nil {
		return m.FailedNodeId
	}
	return ""
}

func (m *Error) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func init() {
	proto.RegisterType((*SchemaType)(nil), "core.SchemaType")
	proto.RegisterType((*SchemaType_SchemaColumn)(nil), "core.SchemaType.SchemaColumn")
	proto.RegisterType((*LiteralType)(nil), "core.LiteralType")
	proto.RegisterType((*OutputReference)(nil), "core.OutputReference")
	proto.RegisterType((*Error)(nil), "core.Error")
	proto.RegisterEnum("core.SimpleType", SimpleType_name, SimpleType_value)
	proto.RegisterEnum("core.SchemaType_SchemaColumn_SchemaColumnType", SchemaType_SchemaColumn_SchemaColumnType_name, SchemaType_SchemaColumn_SchemaColumnType_value)
}

func init() { proto.RegisterFile("core/types.proto", fileDescriptor_types_98913e853d6ccda5) }

var fileDescriptor_types_98913e853d6ccda5 = []byte{
	// 485 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x93, 0xdf, 0x8e, 0x93, 0x40,
	0x14, 0xc6, 0x4b, 0xa1, 0xb0, 0x9c, 0x56, 0x76, 0x9c, 0x1b, 0x1b, 0x13, 0x93, 0x86, 0x78, 0xd1,
	0xec, 0x45, 0x4d, 0xea, 0x85, 0x31, 0xd9, 0x1b, 0x50, 0xec, 0x92, 0x20, 0x24, 0xb3, 0xa8, 0xd1,
	0x1b, 0x32, 0xd2, 0x59, 0x25, 0xe1, 0x5f, 0x80, 0x6e, 0xb2, 0x4f, 0xe1, 0x85, 0x0f, 0xe5, 0x9b,
	0xf8, 0x1c, 0x66, 0x0e, 0xec, 0x96, 0x9a, 0xe8, 0xdd, 0x7c, 0x73, 0x7e, 0xdf, 0xe1, 0x1c, 0xbe,
	0x0c, 0x90, 0xb4, 0x6a, 0xc4, 0x8b, 0xee, 0xae, 0x16, 0xed, 0xa6, 0x6e, 0xaa, 0xae, 0xa2, 0x9a,
	0xbc, 0xb1, 0x7f, 0x4c, 0x01, 0xae, 0xd3, 0xef, 0xa2, 0xe0, 0xf1, 0x5d, 0x2d, 0xe8, 0x2b, 0x30,
	0xd2, 0x2a, 0x3f, 0x14, 0x65, 0xbb, 0x54, 0x57, 0xea, 0x7a, 0xbe, 0x7d, 0xb6, 0x91, 0xd8, 0xe6,
	0x88, 0x0c, 0xc7, 0x37, 0x48, 0xb1, 0x7b, 0xfa, 0xe9, 0x2f, 0x05, 0x16, 0xe3, 0x0a, 0xa5, 0xa0,
	0x95, 0xbc, 0x10, 0x4b, 0x65, 0xa5, 0xac, 0x4d, 0x86, 0x67, 0xea, 0x82, 0x26, 0x27, 0x58, 0x4e,
	0x57, 0xca, 0xda, 0xda, 0x6e, 0xfe, 0xdb, 0xfa, 0x44, 0xc8, 0x2a, 0x43, 0xaf, 0x9d, 0x00, 0xf9,
	0xbb, 0x42, 0xe7, 0x60, 0xf8, 0x61, 0xec, 0xed, 0x3c, 0x46, 0x26, 0xd4, 0x84, 0xd9, 0xbb, 0x20,
	0x72, 0x62, 0xa2, 0x50, 0x00, 0xfd, 0x3a, 0x66, 0x7e, 0xb8, 0x23, 0x53, 0xba, 0x80, 0xb3, 0xb7,
	0x4e, 0xec, 0xc5, 0xfe, 0x7b, 0x8f, 0xa8, 0xa8, 0x3e, 0x30, 0x27, 0xf6, 0xa3, 0x90, 0x68, 0xd2,
	0xef, 0x46, 0x51, 0xe0, 0x39, 0x21, 0x99, 0xd9, 0xbf, 0x15, 0x98, 0x07, 0x59, 0x27, 0x1a, 0x9e,
	0x63, 0xf3, 0x0b, 0xd0, 0xdb, 0xac, 0xa8, 0xf3, 0x7e, 0x15, 0x6b, 0x4b, 0x86, 0xb1, 0xf1, 0x4e,
	0x12, 0x57, 0x13, 0x36, 0x10, 0xc8, 0xe2, 0x70, 0xb8, 0xe2, 0xfc, 0x81, 0x7d, 0x58, 0x11, 0x59,
	0x54, 0xf4, 0x12, 0xce, 0xd3, 0x2a, 0xcf, 0x45, 0xda, 0x65, 0x55, 0x99, 0xe0, 0x7f, 0x51, 0xd1,
	0xf4, 0xb8, 0x37, 0x8d, 0x66, 0xb8, 0x9a, 0x30, 0xeb, 0xc8, 0xe2, 0x54, 0xaf, 0xc1, 0x2a, 0x78,
	0x9d, 0xdc, 0xf2, 0xfc, 0x20, 0x7a, 0xb3, 0xf6, 0x6f, 0xf3, 0xa2, 0xe0, 0xf5, 0x47, 0x49, 0x4a,
	0xed, 0xea, 0x7d, 0x0a, 0xf6, 0x25, 0x9c, 0x47, 0x87, 0xae, 0x3e, 0x74, 0x4c, 0xdc, 0x88, 0x46,
	0x94, 0xa9, 0xa0, 0x4f, 0xc0, 0x28, 0xab, 0xbd, 0x48, 0xb2, 0xfd, 0x90, 0x9b, 0x2e, 0xa5, 0xbf,
	0xa7, 0x04, 0xd4, 0x5b, 0xde, 0xe0, 0x56, 0x26, 0x93, 0x47, 0x7b, 0x07, 0x33, 0xaf, 0x69, 0xaa,
	0x86, 0x3e, 0x07, 0xeb, 0x86, 0x67, 0xb9, 0xd8, 0x27, 0xa7, 0xd6, 0x45, 0x7f, 0x1b, 0xf6, 0x0d,
	0x96, 0x60, 0x14, 0xa2, 0x6d, 0xf9, 0x37, 0x31, 0x34, 0xb9, 0x97, 0x17, 0x3f, 0x15, 0x80, 0xe3,
	0xcf, 0xa4, 0x67, 0xa0, 0x85, 0x51, 0xe8, 0x91, 0xc9, 0x38, 0x55, 0xe5, 0x98, 0xea, 0x74, 0x94,
	0xaa, 0x3a, 0x4e, 0x4e, 0xa3, 0x8f, 0xc0, 0x94, 0x11, 0x27, 0x98, 0xf1, 0xec, 0x24, 0x63, 0x5d,
	0xf6, 0x75, 0x83, 0xc8, 0x25, 0x86, 0xf4, 0xbb, 0x7e, 0xe8, 0xb0, 0xcf, 0xe4, 0x4c, 0x32, 0x9f,
	0x1c, 0x3f, 0x76, 0xdc, 0xc0, 0x23, 0xa6, 0xfc, 0x88, 0xc7, 0x58, 0xc4, 0x08, 0xb8, 0xfa, 0x17,
	0x7c, 0x1f, 0x5f, 0x75, 0x7c, 0x2c, 0x2f, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0x0a, 0xb2, 0xb1,
	0x65, 0x40, 0x03, 0x00, 0x00,
}
