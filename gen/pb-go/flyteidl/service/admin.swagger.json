{
  "swagger": "2.0",
  "info": {
    "title": "flyteidl/service/admin.proto",
    "version": "version not set"
  },
  "schemes": [
    "http",
    "https"
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/api/v1/launch_plans": {
      "post": {
        "operationId": "CreateLaunchPlan",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/adminLaunchPlanCreateResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/adminLaunchPlanCreateRequest"
            }
          }
        ],
        "tags": [
          "AdminService"
        ]
      }
    },
    "/api/v1/project/{project}/domain/{domain}/task_ids": {
      "get": {
        "operationId": "ListTaskIds",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/adminIdentifierList"
            }
          }
        },
        "parameters": [
          {
            "name": "project",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "domain",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "name",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "filters",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "AdminService"
        ]
      }
    },
    "/api/v1/project/{project}/domain/{domain}/tasks": {
      "get": {
        "operationId": "ListTasks",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/adminTaskList"
            }
          }
        },
        "parameters": [
          {
            "name": "project",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "domain",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "name",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "filters",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "AdminService"
        ]
      }
    },
    "/api/v1/project/{project}/domain/{domain}/tasks/{name}": {
      "get": {
        "operationId": "ListTasks2",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/adminTaskList"
            }
          }
        },
        "parameters": [
          {
            "name": "project",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "domain",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "name",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "filters",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "AdminService"
        ]
      }
    },
    "/api/v1/project/{project}/domain/{domain}/workflow_ids": {
      "get": {
        "operationId": "ListWorkflowIds",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/adminIdentifierList"
            }
          }
        },
        "parameters": [
          {
            "name": "project",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "domain",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "name",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "filters",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "AdminService"
        ]
      }
    },
    "/api/v1/project/{project}/domain/{domain}/workflows": {
      "get": {
        "operationId": "ListWorkflows",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/adminWorkflowList"
            }
          }
        },
        "parameters": [
          {
            "name": "project",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "domain",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "name",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "filters",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "AdminService"
        ]
      }
    },
    "/api/v1/project/{project}/domain/{domain}/workflows/{name}": {
      "get": {
        "operationId": "ListWorkflows2",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/adminWorkflowList"
            }
          }
        },
        "parameters": [
          {
            "name": "project",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "domain",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "name",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "filters",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "AdminService"
        ]
      }
    },
    "/api/v1/tasks": {
      "post": {
        "operationId": "CreateTask",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/adminTaskCreateResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/adminTaskCreateRequest"
            }
          }
        ],
        "tags": [
          "AdminService"
        ]
      }
    },
    "/api/v1/tasks/{urn}": {
      "get": {
        "operationId": "GetTask",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/adminTask"
            }
          }
        },
        "parameters": [
          {
            "name": "urn",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "AdminService"
        ]
      }
    },
    "/api/v1/workflows": {
      "post": {
        "operationId": "CreateWorkflow",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/adminWorkflowCreateResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/adminWorkflowCreateRequest"
            }
          }
        ],
        "tags": [
          "AdminService"
        ]
      }
    },
    "/api/v1/workflows/{urn}": {
      "get": {
        "operationId": "GetWorkflow",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/adminWorkflow"
            }
          }
        },
        "parameters": [
          {
            "name": "urn",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "AdminService"
        ]
      }
    }
  },
  "definitions": {
    "BlobMetadataBlobType": {
      "type": "string",
      "enum": [
        "Single",
        "Multipart"
      ],
      "default": "Single"
    },
    "ComparisonExpressionOperator": {
      "type": "string",
      "enum": [
        "EQ",
        "NEQ",
        "GT",
        "GTE",
        "LT",
        "LTE"
      ],
      "default": "EQ",
      "description": "- GT: Greater Than\n - LT: Less Than",
      "title": "Binary Operator for each expression"
    },
    "ConjunctionExpressionLogicalOperator": {
      "type": "string",
      "enum": [
        "AND",
        "OR"
      ],
      "default": "AND",
      "description": "- AND: Conjunction",
      "title": "Nested conditions. They can be conjoined using AND / OR\nOrder of evaluation is not important as the operators are Commutative"
    },
    "ResourcesResourceEntry": {
      "type": "object",
      "properties": {
        "name": {
          "$ref": "#/definitions/ResourcesResourceName",
          "description": "Resource name."
        },
        "value": {
          "type": "string",
          "description": "Value must be a valid k8s quantity."
        }
      },
      "description": "Encapsulates a resource name and value."
    },
    "ResourcesResourceName": {
      "type": "string",
      "enum": [
        "Unknown",
        "Cpu",
        "Gpu",
        "Memory",
        "Storage"
      ],
      "default": "Unknown",
      "description": "Known resource names."
    },
    "RuntimeMetadataRuntimeType": {
      "type": "string",
      "enum": [
        "Other",
        "FlyteSDK"
      ],
      "default": "Other"
    },
    "ScheduleFixedRate": {
      "type": "object",
      "properties": {
        "value": {
          "type": "integer",
          "format": "int64"
        },
        "unit": {
          "$ref": "#/definitions/ScheduleFixedRateUnit"
        }
      }
    },
    "ScheduleFixedRateUnit": {
      "type": "string",
      "enum": [
        "MINUTE",
        "HOUR",
        "DAY"
      ],
      "default": "MINUTE"
    },
    "SchemaColumnSchemaColumnType": {
      "type": "string",
      "enum": [
        "INTEGER",
        "FLOAT",
        "STRING",
        "DATETIME",
        "DURATION",
        "BOOLEAN"
      ],
      "default": "INTEGER"
    },
    "SchemaTypeSchemaColumn": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "title": "A unique name -within the schema type- for the column"
        },
        "type": {
          "$ref": "#/definitions/SchemaColumnSchemaColumnType",
          "description": "The column type. This allows a limited set of types currently."
        }
      }
    },
    "adminExecutionPhase": {
      "type": "string",
      "enum": [
        "UNDEFINED",
        "RUNNING",
        "SUCCEEDED",
        "FAILED",
        "TIMED_OUT",
        "ABORTED",
        "QUEUED"
      ],
      "default": "UNDEFINED",
      "title": "Indicates various states of an Execution - both task and workflow"
    },
    "adminIdentifier": {
      "type": "object",
      "properties": {
        "project": {
          "type": "string"
        },
        "domain": {
          "type": "string"
        },
        "name": {
          "type": "string"
        }
      },
      "title": "Encapsulation of fields that identifies a Flyte resource"
    },
    "adminIdentifierList": {
      "type": "object",
      "properties": {
        "entities": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/adminIdentifier"
          }
        }
      }
    },
    "adminLaunchPlanCreateRequest": {
      "type": "object",
      "properties": {
        "id": {
          "$ref": "#/definitions/adminIdentifier"
        },
        "version": {
          "type": "string"
        },
        "spec": {
          "$ref": "#/definitions/adminLaunchPlanSpec"
        }
      }
    },
    "adminLaunchPlanCreateResponse": {
      "type": "object",
      "properties": {
        "urn": {
          "type": "string"
        }
      }
    },
    "adminLaunchPlanMetadata": {
      "type": "object",
      "properties": {
        "schedule": {
          "$ref": "#/definitions/adminSchedule",
          "title": "Schedule to execute the Launch Plan"
        },
        "notifications": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/adminNotification"
          },
          "title": "List of notifications based on Execution status transitions"
        }
      }
    },
    "adminLaunchPlanSpec": {
      "type": "object",
      "properties": {
        "workflow_urn": {
          "type": "string",
          "title": "Reference to the Workflow template that the launch plan references"
        },
        "entity_metadata": {
          "$ref": "#/definitions/adminLaunchPlanMetadata",
          "title": "Metadata for the Launch Plan"
        },
        "default_inputs": {
          "$ref": "#/definitions/coreParameterMap",
          "title": "Input values to be passed for the execution"
        },
        "fixed_inputs": {
          "$ref": "#/definitions/coreLiteralMap",
          "title": "Fixed, non overridable inputs for the Launch Plan"
        }
      }
    },
    "adminNotification": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/adminNotificationType"
        },
        "phases": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/adminExecutionPhase"
          }
        }
      },
      "description": "Structure of notifications based on execution status."
    },
    "adminNotificationType": {
      "type": "string",
      "enum": [
        "UNDEFINED",
        "EMAIL",
        "PAGER_DUTY",
        "SLACK"
      ],
      "default": "UNDEFINED"
    },
    "adminSchedule": {
      "type": "object",
      "properties": {
        "cron_expression": {
          "type": "string"
        },
        "fixed_rate": {
          "$ref": "#/definitions/ScheduleFixedRate"
        },
        "kickoff_time_input_arg": {
          "type": "string"
        }
      }
    },
    "adminTask": {
      "type": "object",
      "properties": {
        "id": {
          "$ref": "#/definitions/adminIdentifier"
        },
        "version": {
          "type": "string"
        },
        "urn": {
          "type": "string"
        },
        "spec": {
          "$ref": "#/definitions/adminTaskSpec"
        }
      }
    },
    "adminTaskCreateRequest": {
      "type": "object",
      "properties": {
        "id": {
          "$ref": "#/definitions/adminIdentifier"
        },
        "version": {
          "type": "string"
        },
        "spec": {
          "$ref": "#/definitions/adminTaskSpec"
        }
      }
    },
    "adminTaskCreateResponse": {
      "type": "object",
      "properties": {
        "urn": {
          "type": "string"
        }
      }
    },
    "adminTaskList": {
      "type": "object",
      "properties": {
        "tasks": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/adminTask"
          }
        },
        "offset": {
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "adminTaskSpec": {
      "type": "object",
      "properties": {
        "template": {
          "$ref": "#/definitions/coreTaskTemplate"
        }
      }
    },
    "adminWorkflow": {
      "type": "object",
      "properties": {
        "id": {
          "$ref": "#/definitions/adminIdentifier"
        },
        "version": {
          "type": "string"
        },
        "urn": {
          "type": "string"
        },
        "spec": {
          "$ref": "#/definitions/adminWorkflowSpec"
        }
      }
    },
    "adminWorkflowCreateRequest": {
      "type": "object",
      "properties": {
        "id": {
          "$ref": "#/definitions/adminIdentifier"
        },
        "version": {
          "type": "string"
        },
        "spec": {
          "$ref": "#/definitions/adminWorkflowSpec"
        }
      }
    },
    "adminWorkflowCreateResponse": {
      "type": "object",
      "properties": {
        "urn": {
          "type": "string"
        }
      }
    },
    "adminWorkflowList": {
      "type": "object",
      "properties": {
        "workflows": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/adminWorkflow"
          }
        },
        "offset": {
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "adminWorkflowSpec": {
      "type": "object",
      "properties": {
        "workflow_template": {
          "$ref": "#/definitions/coreWorkflowTemplate"
        }
      }
    },
    "coreAlias": {
      "type": "object",
      "properties": {
        "var": {
          "type": "string",
          "description": "Must match one of the output variable names on a node."
        },
        "alias": {
          "type": "string",
          "description": "A workflow-level unique alias that downstream nodes can refer to in their input."
        }
      },
      "description": "Links a variable to an alias."
    },
    "coreBinary": {
      "type": "object",
      "properties": {
        "value": {
          "type": "string",
          "format": "byte"
        },
        "tag": {
          "type": "string"
        }
      },
      "description": "A simple byte array with a tag to help different parts of the system communicate about what is in the byte array.\nIt's strongly advisable that consumers of this type define a unique tag and validate the tag before parsing the data."
    },
    "coreBinding": {
      "type": "object",
      "properties": {
        "var": {
          "type": "string",
          "description": "Variable name must match an input/output variable of the node."
        },
        "binding": {
          "$ref": "#/definitions/coreBindingData",
          "description": "Data to use to bind this variable."
        }
      },
      "description": "An input/output binding of a variable to either static value or a node output."
    },
    "coreBindingData": {
      "type": "object",
      "properties": {
        "scalar": {
          "$ref": "#/definitions/coreScalar",
          "description": "A simple scalar value."
        },
        "collection": {
          "$ref": "#/definitions/coreBindingDataCollection",
          "description": "A collection of binding data. This allows nesting of binding data to any number\nof levels."
        },
        "promise": {
          "$ref": "#/definitions/coreOutputReference",
          "description": "References an output promised by another node."
        },
        "map": {
          "$ref": "#/definitions/coreBindingDataMap",
          "description": "A map of bindings. The key is always a string."
        }
      },
      "description": "Specifies either a simple value or a reference to another output."
    },
    "coreBindingDataCollection": {
      "type": "object",
      "properties": {
        "bindings": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/coreBindingData"
          }
        }
      },
      "description": "A collection of BindingData items."
    },
    "coreBindingDataMap": {
      "type": "object",
      "properties": {
        "bindings": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/coreBindingData"
          }
        }
      },
      "description": "A map of BindingData items."
    },
    "coreBlob": {
      "type": "object",
      "properties": {
        "metadata": {
          "$ref": "#/definitions/coreBlobMetadata"
        },
        "uri": {
          "type": "string"
        }
      },
      "description": "Refers to an offloaded set of files. It encapsulates the type of the store and a unique uri for where the data is.\nThere are no restrictions on how the uri is formatted since it will depend on how to interact with the store."
    },
    "coreBlobMetadata": {
      "type": "object",
      "properties": {
        "format": {
          "type": "string",
          "title": "Format can be a free form string understood by SDK/UI etc like\ncsv, parquet etc"
        },
        "type": {
          "$ref": "#/definitions/BlobMetadataBlobType"
        }
      }
    },
    "coreBooleanExpression": {
      "type": "object",
      "properties": {
        "conjunction": {
          "$ref": "#/definitions/coreConjunctionExpression"
        },
        "comparison": {
          "$ref": "#/definitions/coreComparisonExpression"
        }
      },
      "description": "Defines a boolean expression tree. It can be a simple or a conjunction expression.\nMultiple expressions can be combined using a conjunction or a disjuntion to result in final boolean result."
    },
    "coreBranchNode": {
      "type": "object",
      "properties": {
        "if_else": {
          "$ref": "#/definitions/coreIfElseBlock",
          "title": "+required"
        }
      },
      "description": "BranchNode is a special node that alter the flow of the workflow graph. It allows the control flow to branch at\nruntime based on a series of conditions that get evaluated on various parameters (e.g. inputs, primtives)."
    },
    "coreComparisonExpression": {
      "type": "object",
      "properties": {
        "operator": {
          "$ref": "#/definitions/ComparisonExpressionOperator"
        },
        "left_value": {
          "$ref": "#/definitions/coreOperand"
        },
        "right_value": {
          "$ref": "#/definitions/coreOperand"
        }
      },
      "description": "Defines a 2-level tree where the root is a comparison operator and Operands are primtivies or known variables.\nEach expression results in a boolean result."
    },
    "coreConjunctionExpression": {
      "type": "object",
      "properties": {
        "operator": {
          "$ref": "#/definitions/ConjunctionExpressionLogicalOperator"
        },
        "left_expression": {
          "$ref": "#/definitions/coreBooleanExpression"
        },
        "right_expression": {
          "$ref": "#/definitions/coreBooleanExpression"
        }
      },
      "description": "Defines a conjunction expression of two boolean expressions."
    },
    "coreContainer": {
      "type": "object",
      "properties": {
        "image": {
          "type": "string",
          "title": "Container image url. Eg: docker/redis:latest"
        },
        "command": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Command to be executed, if not provided, the default entrypoint in the container image will be used."
        },
        "args": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "These will default to Flyte given paths. If provided, the system will not append known paths. If the task still\nneeds flyte's inputs and outputs path, add $(FLYTE_INPUT_FILE), $(FLYTE_OUTPUT_FILE) wherever makes sense and the\nsystem will populate these before executing the container."
        },
        "resources": {
          "$ref": "#/definitions/coreResources",
          "description": "Container resources requirement as specified by the container engine."
        },
        "env": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/coreKeyValuePair"
          },
          "description": "Environment variables will be set as the container is starting up."
        },
        "config": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/coreKeyValuePair"
          },
          "description": "Allows extra configs to be available for the container.\nTODO: elaborate on how configs will become available."
        }
      }
    },
    "coreError": {
      "type": "object",
      "properties": {
        "failed_node_id": {
          "type": "string",
          "description": "The node id that threw the error."
        },
        "message": {
          "type": "string",
          "description": "Error message thrown."
        }
      },
      "description": "Represents an error thrown from a node."
    },
    "coreIfBlock": {
      "type": "object",
      "properties": {
        "condition": {
          "$ref": "#/definitions/coreBooleanExpression"
        },
        "then_node": {
          "$ref": "#/definitions/coreNode"
        }
      },
      "description": "Defines a condition and the execution unit that should be executed if the condition is satisfied."
    },
    "coreIfElseBlock": {
      "type": "object",
      "properties": {
        "case": {
          "$ref": "#/definitions/coreIfBlock",
          "description": "+required. First condition to evaluate."
        },
        "other": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/coreIfBlock"
          },
          "description": "+optional. Additional branches to evaluate."
        },
        "else_node": {
          "$ref": "#/definitions/coreNode",
          "description": "The node to execute in case non of the branches were taken."
        },
        "error": {
          "$ref": "#/definitions/coreError",
          "description": "An error to throw in case non of the branches were taken."
        }
      },
      "description": "Defines a series of if/else blocks. The first branch whose condition evaluates to true is the one to execute.\nIf no conditions were satisfied, the else_node will be executed."
    },
    "coreKeyValuePair": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "description": "required."
        },
        "value": {
          "type": "string",
          "description": "+optional."
        }
      },
      "description": "A generic key value pair."
    },
    "coreLiteral": {
      "type": "object",
      "properties": {
        "scalar": {
          "$ref": "#/definitions/coreScalar",
          "description": "A simple value."
        },
        "collection": {
          "$ref": "#/definitions/coreLiteralCollection",
          "description": "A collection of literals to allow nesting."
        },
        "map": {
          "$ref": "#/definitions/coreLiteralMap",
          "description": "A map of strings to literals."
        }
      },
      "description": "A simple value. This supports any level of nesting (e.g. array of array of array of Blobs) as well as simple primitives."
    },
    "coreLiteralCollection": {
      "type": "object",
      "properties": {
        "literals": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/coreLiteral"
          }
        }
      },
      "description": "A collection of literals. This is a workaround since oneofs in proto messages cannot contain a repeated field."
    },
    "coreLiteralMap": {
      "type": "object",
      "properties": {
        "literals": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/coreLiteral"
          }
        }
      },
      "description": "A map of literals. This is a workaround since oneofs in proto messages cannot contain a repeated field."
    },
    "coreLiteralType": {
      "type": "object",
      "properties": {
        "simple": {
          "$ref": "#/definitions/coreSimpleType",
          "description": "A simple type that can be compared one-to-one with another."
        },
        "schema": {
          "$ref": "#/definitions/coreSchemaType",
          "description": "A complex type that requires matching of inner fields."
        },
        "collection_type": {
          "$ref": "#/definitions/coreLiteralType",
          "description": "Defines the type of the value of a collection. Only homogeneous collections are allowed."
        },
        "map_value_type": {
          "$ref": "#/definitions/coreLiteralType",
          "description": "Defines the type of the value of a map type. The type of the key is always a string."
        }
      },
      "description": "Defines a strong type to allow type checking between interfaces."
    },
    "coreNode": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "A workflow-level unique identifier that identifies this node in the workflow. \"inputs\" and \"outputs\" are reserved\nnode ids that cannot be used by other nodes."
        },
        "metadata": {
          "$ref": "#/definitions/coreNodeMetadata",
          "description": "Extra metadata about the node."
        },
        "inputs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/coreBinding"
          },
          "description": "Specifies how to bind the underlying interface's inputs. All required inputs specified in the underlying interface\nmust be fullfilled."
        },
        "upstream_node_ids": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "+optional Specifies execution depdendency for this node ensuring it will only get scheduled to run after all its\nupstream nodes have completed. This node will have an implicit depdendency on any node that appears in inputs\nfield."
        },
        "output_aliases": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/coreAlias"
          },
          "description": "+optional. A node can define aliases for a subset of its outputs. This is particularly useful if different nodes\nneed to conform to the same interface (e.g. all branches in a branch node). Downstream nodes must refer to this\nnodes outputs using the alias if one's specified."
        },
        "task_node": {
          "$ref": "#/definitions/coreTaskNode",
          "description": "Information about the Task to execute in this node."
        },
        "workflow_node": {
          "$ref": "#/definitions/coreWorkflowNode",
          "description": "Information about the Workflow to execute in this mode."
        },
        "branch_node": {
          "$ref": "#/definitions/coreBranchNode",
          "description": "Information about the branch node to evaluate in this node."
        }
      },
      "description": "A Workflow graph Node. One unit of execution in the graph. Each node can be linked to a Task, a Workflow or a branch\nnode."
    },
    "coreNodeMetadata": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "title": "A friendly name for the Node"
        },
        "timeout": {
          "type": "string",
          "description": "The overall timeout of a task."
        },
        "retries": {
          "$ref": "#/definitions/coreRetryStrategy",
          "description": "Number of retries per task."
        }
      },
      "description": "Defines extra information about the Node."
    },
    "coreOperand": {
      "type": "object",
      "properties": {
        "primitive": {
          "$ref": "#/definitions/corePrimitive",
          "title": "Can be a constant"
        },
        "var": {
          "type": "string",
          "title": "Or one of this node's input variables"
        }
      },
      "description": "Defines an operand to a comparison expression."
    },
    "coreOutputReference": {
      "type": "object",
      "properties": {
        "node_id": {
          "type": "string",
          "description": "Node id must exist at the graph layer."
        },
        "var": {
          "type": "string",
          "description": "Variable name must refer to an output variable for the node."
        }
      },
      "description": "A reference to an output produced by a node. The type can be retrieved -and validated- from\nthe underlying interface of the node."
    },
    "coreParameter": {
      "type": "object",
      "properties": {
        "var": {
          "$ref": "#/definitions/coreVariable",
          "description": "+required Variable. Defines a name and a type to reference/compare through out the system."
        },
        "default": {
          "$ref": "#/definitions/coreLiteral",
          "description": "Defines a default value that has to match the variable type defined."
        },
        "required": {
          "type": "boolean",
          "format": "boolean",
          "description": "+optional, is this value required to be filled."
        }
      },
      "description": "Declares an input parameter."
    },
    "coreParameterMap": {
      "type": "object",
      "properties": {
        "parameters": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/coreParameter"
          }
        }
      },
      "description": "A map of Parameters."
    },
    "corePrimitive": {
      "type": "object",
      "properties": {
        "integer": {
          "type": "string",
          "format": "int64"
        },
        "float_value": {
          "type": "number",
          "format": "double"
        },
        "string_value": {
          "type": "string"
        },
        "boolean": {
          "type": "boolean",
          "format": "boolean"
        },
        "datetime": {
          "type": "string",
          "format": "date-time"
        },
        "duration": {
          "type": "string"
        }
      },
      "title": "Primitive Types"
    },
    "coreResources": {
      "type": "object",
      "properties": {
        "requests": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ResourcesResourceEntry"
          },
          "description": "The desired set of resources requested."
        },
        "limits": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ResourcesResourceEntry"
          },
          "description": "Defines a set of bounds (e.g. min/max) within which the task can reliably run."
        }
      },
      "description": "A customizable interface to convey resources requested for a container. This can be interpretted differently for different\ncontainer engines."
    },
    "coreRetryStrategy": {
      "type": "object",
      "properties": {
        "retries": {
          "type": "integer",
          "format": "int64",
          "description": "Number of retries. Retries will be consumed when the job fails with a recoverable error.\nThe number of retries must be less than or equals to 10."
        }
      },
      "description": "Retry strategy associated with an executable unit."
    },
    "coreRuntimeMetadata": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/RuntimeMetadataRuntimeType",
          "description": "Type of runtime."
        },
        "version": {
          "type": "string",
          "description": "Version of the runtime. All versions should be backward compatible. However, certain cases call for version\nchecks to ensure tighter validation or setting expectations."
        },
        "flavor": {
          "type": "string",
          "description": "+optional It can be used to provide extra information about the runtime (e.g. python, golang... etc.)."
        }
      },
      "description": "Runtime information. This is losely defined to allow for extensibility."
    },
    "coreScalar": {
      "type": "object",
      "properties": {
        "primitive": {
          "$ref": "#/definitions/corePrimitive"
        },
        "blob": {
          "$ref": "#/definitions/coreBlob"
        },
        "binary": {
          "$ref": "#/definitions/coreBinary"
        },
        "schema": {
          "$ref": "#/definitions/coreSchema"
        },
        "none_type": {
          "$ref": "#/definitions/coreVoid"
        },
        "waitable": {
          "$ref": "#/definitions/coreWaitable",
          "title": "Backwards compatibility"
        },
        "error": {
          "$ref": "#/definitions/coreError"
        }
      }
    },
    "coreSchema": {
      "type": "object",
      "properties": {
        "uri": {
          "type": "string"
        },
        "type": {
          "$ref": "#/definitions/coreSchemaType"
        }
      },
      "description": "A strongly typed schema that defines the interface of data retrieved from the underlying storage medium."
    },
    "coreSchemaType": {
      "type": "object",
      "properties": {
        "columns": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/SchemaTypeSchemaColumn"
          },
          "description": "A list of ordered columns this schema comprises of."
        }
      },
      "description": "Defines schema columns and types to strongly type-validate schemas interoperability."
    },
    "coreSimpleType": {
      "type": "string",
      "enum": [
        "NONE",
        "INTEGER",
        "FLOAT",
        "STRING",
        "BOOLEAN",
        "DATE_TIME",
        "DURATION",
        "BLOB",
        "BINARY",
        "WAITABLE",
        "ERROR"
      ],
      "default": "NONE",
      "description": "Define a set of simple types."
    },
    "coreTaskCategory": {
      "type": "string",
      "enum": [
        "SingleStepTask",
        "MultiStepTask"
      ],
      "default": "SingleStepTask",
      "title": "- SingleStepTask: Task category that identifies if the system can use default structures in UI, etc to drive the task\nTODO should we add Container type of tasks as a special Class?"
    },
    "coreTaskMetadata": {
      "type": "object",
      "properties": {
        "discoverable": {
          "type": "boolean",
          "format": "boolean",
          "description": "Indicates whether the system should attempt to lookup this task's output to avoid duplication of work."
        },
        "runtime": {
          "$ref": "#/definitions/coreRuntimeMetadata",
          "description": "Runtime information about the task."
        },
        "timeout": {
          "type": "string",
          "description": "The overall timeout of a task."
        },
        "retries": {
          "$ref": "#/definitions/coreRetryStrategy",
          "description": "Number of retries per task."
        }
      },
      "title": "Task Metadata"
    },
    "coreTaskNode": {
      "type": "object",
      "properties": {
        "reference_id": {
          "type": "string",
          "description": "A globally unique identifier for the task."
        }
      },
      "description": "Refers to the task that the Node is to execute."
    },
    "coreTaskTemplate": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Auto generated taskId by the system. Task Id uniquely identifies this task globally."
        },
        "category": {
          "$ref": "#/definitions/coreTaskCategory",
          "title": "Category of the task. These are predefined and help provide defaults"
        },
        "type": {
          "type": "string",
          "description": "A predefined yet extensible Task type identifier. This can be used to customize any of the components. If no\nextensions are provided in the system, Flyte will resolve the this task to its TaskCategory and default the\nimplementation registered for the TaskCategory."
        },
        "metadata": {
          "$ref": "#/definitions/coreTaskMetadata",
          "description": "Extra metadata about the task."
        },
        "interface": {
          "$ref": "#/definitions/coreTypedInterface",
          "description": "A strongly typed interface for the task. This enables others to use this task within a workflow and gauarantees\ncompile-time validation of the workflow to avoid costly runtime failures."
        },
        "custom": {
          "type": "string",
          "format": "byte",
          "description": "Custom data about the task. This is extensible to allow various plugins in the system."
        },
        "container": {
          "$ref": "#/definitions/coreContainer"
        }
      },
      "description": "A Task structure that uniquely identifies a task in the system\nTasks are registered as a first step in the system."
    },
    "coreTypedInterface": {
      "type": "object",
      "properties": {
        "inputs": {
          "$ref": "#/definitions/coreVariableMap"
        },
        "outputs": {
          "$ref": "#/definitions/coreVariableMap"
        }
      },
      "description": "Defines strongly typed inputs and outputs."
    },
    "coreVariable": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/coreLiteralType",
          "description": "Variable literal type."
        },
        "description": {
          "type": "string",
          "title": "+optional string describing input variable"
        }
      },
      "description": "Defines a strongly typed variable."
    },
    "coreVariableMap": {
      "type": "object",
      "properties": {
        "variables": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/coreVariable"
          }
        }
      },
      "title": "A map of Variables"
    },
    "coreVoid": {
      "type": "object"
    },
    "coreWaitable": {
      "type": "object",
      "properties": {
        "surrogate_key": {
          "type": "string"
        },
        "execution_uri": {
          "type": "string"
        }
      },
      "description": "Defines an execution unit recognized by the system and can be referred to by other units to listen to its execution\nevents (started, succeeded, aborted... etc.)."
    },
    "coreWorkflowMetadata": {
      "type": "object",
      "properties": {
        "execution_role": {
          "type": "string"
        }
      },
      "description": "Metadata for the entire workflow."
    },
    "coreWorkflowNode": {
      "type": "object",
      "properties": {
        "launchplan_ref": {
          "type": "string",
          "description": "A globally unique identifier for the launch plan."
        },
        "sub_workflow_ref": {
          "type": "string",
          "title": "Reference to a subworkflow, that should be defined with the compiler context"
        }
      },
      "description": "Refers to a the workflow the node is to execute."
    },
    "coreWorkflowTemplate": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "This is an autogenerated id by the system. The id is globally unique across the system."
        },
        "metadata": {
          "$ref": "#/definitions/coreWorkflowMetadata",
          "description": "Extra metadata about the workflow."
        },
        "interface": {
          "$ref": "#/definitions/coreTypedInterface",
          "description": "Defines a strongly typed interface for the Workflow. This can include some optional parameters."
        },
        "nodes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/coreNode"
          },
          "description": "A list of nodes. In addition, \"globals\" is a special reserved node id that can be used to consume workflow inputs."
        },
        "outputs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/coreBinding"
          },
          "description": "A list of output bindings that specify how to construct workflow outputs. Bindings can pull node outputs or\nspecify literals. All workflow outputs specified in the interface field must be bound in order for the workflow\nto be validated. A workflow has an implicit depdendency on all of its nodes to execute successfully in order to\nbind final outputs."
        },
        "failure_node": {
          "$ref": "#/definitions/coreNode",
          "description": "+optional A catch-all node. This node is executed whenever the execution engine determines the workflow has failed.\nThe interface of this node must match the Workflow interface with an additional input named \"error\" of type\npb.lyft.flyte.core.Error."
        }
      },
      "description": "Flyte Workflow Structure that encapsulates task, branch and subworkflow nodes to form a statically analyzable,\ndirected acyclic graph."
    }
  }
}
