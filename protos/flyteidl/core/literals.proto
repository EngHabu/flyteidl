syntax = "proto3";

package flyteidl.core;

option go_package = "github.com/lyft/flyteidl/gen/pb-go/flyteidl/core";

import "flyteidl/core/identifier.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/struct.proto";
import "flyteidl/core/types.proto";
import "flyteidl/core/condition.proto";
import "flyteidl/core/tasks.proto";
import "flyteidl/core/workflow.proto";

// Primitive Types
message Primitive {
    // Defines one of simple primitive types. These types will get translated into different programming languages as
    // described in https://developers.google.com/protocol-buffers/docs/proto#scalar.
    oneof value {
        int64 integer = 1;
        double float_value = 2;
        string string_value = 3;
        bool boolean = 4;
        google.protobuf.Timestamp datetime = 5;
        google.protobuf.Duration duration = 6;
    }
}

// Used to denote a nil/null/None assignment to a scalar value. The underlying LiteralType for Void is intentionally
// undefined since it can be assigned to a scalar of any LiteralType.
message Void {
}

// Refers to an offloaded set of files. It encapsulates the type of the store and a unique uri for where the data is.
// There are no restrictions on how the uri is formatted since it will depend on how to interact with the store.
message Blob {
    BlobMetadata metadata = 1;
    string uri = 3;
}

message BlobMetadata {
    BlobType type = 1;
}

// A simple byte array with a tag to help different parts of the system communicate about what is in the byte array.
// It's strongly advisable that consumers of this type define a unique tag and validate the tag before parsing the data.
message Binary {
    bytes value = 1;
    string tag = 2;
}

// A strongly typed schema that defines the interface of data retrieved from the underlying storage medium.
message Schema {
    string uri = 1;
    SchemaType type = 3;
}

message Scalar {
    oneof value {
        Primitive primitive = 1;
        Blob blob = 2;
        Binary binary = 3;
        Schema schema = 4;
        Void none_type = 5;
        Error error = 6;
        google.protobuf.Struct generic = 7;
    }
}

// Represents a node closure that contain all required information to execute.
message NodeClosure {
    // A node to execute.
    Node node = 1;

    // [Optional] A complete list of task specs referenced in node.
    repeated TaskTemplate tasks = 4;

    // [Optional] A complete list of workflow specs referenced in node or in other workflows.
    repeated WorkflowTemplate sub_workflows = 5;
}

// A simple value. This supports any level of nesting (e.g. array of array of array of Blobs) as well as simple primitives.
message Literal {
    oneof value {
        // A simple value.
        Scalar scalar = 1;

        // A collection of literals to allow nesting.
        LiteralCollection collection = 2;

        // A map of strings to literals.
        LiteralMap map = 3;

        NodeClosure closure = 4;
    }
}

// A collection of literals. This is a workaround since oneofs in proto messages cannot contain a repeated field.
message LiteralCollection {
    repeated Literal literals = 1;
}

// A map of literals. This is a workaround since oneofs in proto messages cannot contain a repeated field.
message LiteralMap {
    map<string, Literal> literals = 1;
}

// A collection of BindingData items.
message BindingDataCollection {
    repeated BindingData bindings = 1;
}

// A map of BindingData items.
message BindingDataMap {
    map<string, BindingData> bindings = 1;
}

// Specifies either a simple value or a reference to another output.
message BindingData {
    oneof value {
        // A simple scalar value.
        Scalar scalar = 1;

        // A collection of binding data. This allows nesting of binding data to any number
        // of levels.
        BindingDataCollection collection = 2;

        // References an output promised by another node.
        OutputReference promise = 3;

        // A map of bindings. The key is always a string.
        BindingDataMap map = 4;

        NodeClosure closure = 5;
    }
}

// An input/output binding of a variable to either static value or a node output.
message Binding {
    // Variable name must match an input/output variable of the node.
    string var = 1;

    // Data to use to bind this variable.
    BindingData binding = 2;
}

// A generic key value pair.
message KeyValuePair {
    //required.
    string key = 1;

    //+optional.
    string value = 2;
}

// Retry strategy associated with an executable unit.
message RetryStrategy {
    // Number of retries. Retries will be consumed when the job fails with a recoverable error.
    // The number of retries must be less than or equals to 10.
    uint32 retries = 5;
}

// Defines a condition and the execution unit that should be executed if the condition is satisfied.
message IfBlock {
    core.BooleanExpression condition = 1;
    Node then_node = 2;
}

// Defines a series of if/else blocks. The first branch whose condition evaluates to true is the one to execute.
// If no conditions were satisfied, the else_node or the error will execute.
message IfElseBlock {
    //+required. First condition to evaluate.
    IfBlock case = 1;

    //+optional. Additional branches to evaluate.
    repeated IfBlock other = 2;

    //+required.
    oneof default {
        // The node to execute in case none of the branches were taken.
        Node else_node = 3;

        // An error to throw in case none of the branches were taken.
        Error error = 4;
    }
}

// BranchNode is a special node that alter the flow of the workflow graph. It allows the control flow to branch at
// runtime based on a series of conditions that get evaluated on various parameters (e.g. inputs, primtives).
message BranchNode {
    //+required
    IfElseBlock if_else = 1;
}

// A specialized node type that expects a NodeClosure as the first and only input.
message ClosureNode {
    // Since closures will only be discovered at runtime. The node must statically specify the outputs it promises to
    // generate. If this is not specified, subsequent nodes won't be able to consume the executed closure's output.
    VariableMap outputs = 1;
}

// Refers to the task that the Node is to execute.
message TaskNode {
    oneof reference {
        // A globally unique identifier for the task.
        Identifier reference_id = 1;
    }
}

// Refers to a the workflow the node is to execute.
message WorkflowNode {
    oneof reference {
        // A globally unique identifier for the launch plan.
        Identifier launchplan_ref = 1;

        // Reference to a subworkflow, that should be defined with the compiler context
        Identifier sub_workflow_ref = 2;
    }
}

// Defines extra information about the Node.
message NodeMetadata {
    // A friendly name for the Node
    string name = 1;

    // The overall timeout of a task.
    google.protobuf.Duration timeout = 4;

    // Number of retries per task.
    RetryStrategy retries = 5;
}

// Links a variable to an alias.
message Alias {
    // Must match one of the output variable names on a node.
    string var = 1;

    // A workflow-level unique alias that downstream nodes can refer to in their input.
    string alias = 2;
}

// A Workflow graph Node. One unit of execution in the graph. Each node can be linked to a Task, a Workflow or a branch
// node.
message Node {
    // A workflow-level unique identifier that identifies this node in the workflow. "inputs" and "outputs" are reserved
    // node ids that cannot be used by other nodes.
    string id = 1;

    // Extra metadata about the node.
    NodeMetadata metadata = 2;

    // Specifies how to bind the underlying interface's inputs. All required inputs specified in the underlying interface
    // must be fullfilled.
    repeated Binding inputs = 3;

    //+optional Specifies execution depdendency for this node ensuring it will only get scheduled to run after all its
    // upstream nodes have completed. This node will have an implicit depdendency on any node that appears in inputs
    // field.
    repeated string upstream_node_ids = 4;

    //+optional. A node can define aliases for a subset of its outputs. This is particularly useful if different nodes
    // need to conform to the same interface (e.g. all branches in a branch node). Downstream nodes must refer to this
    // nodes outputs using the alias if one's specified.
    repeated Alias output_aliases = 5;

    // Information about the target to execute in this node.
    oneof target {
        // Information about the Task to execute in this node.
        TaskNode task_node = 6;

        // Information about the Workflow to execute in this mode.
        WorkflowNode workflow_node = 7;

        // Information about the branch node to evaluate in this node.
        BranchNode branch_node = 8;

        ClosureNode closure_node = 9;
    }
}


