// Code generated by protoc-gen-go. DO NOT EDIT.
// source: flyteidl/core/literals.proto

package core // import "github.com/lyft/flyteidl/gen/pb-go/flyteidl/core"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import duration "github.com/golang/protobuf/ptypes/duration"
import _struct "github.com/golang/protobuf/ptypes/struct"
import _ "github.com/golang/protobuf/ptypes/timestamp"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Used to denote a nil/null/None assignment to a scalar value. The underlying LiteralType for Void is intentionally
// undefined since it can be assigned to a scalar of any LiteralType.
type Void struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Void) Reset()         { *m = Void{} }
func (m *Void) String() string { return proto.CompactTextString(m) }
func (*Void) ProtoMessage()    {}
func (*Void) Descriptor() ([]byte, []int) {
	return fileDescriptor_literals_1ac04b6ab2b9b143, []int{0}
}
func (m *Void) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Void.Unmarshal(m, b)
}
func (m *Void) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Void.Marshal(b, m, deterministic)
}
func (dst *Void) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Void.Merge(dst, src)
}
func (m *Void) XXX_Size() int {
	return xxx_messageInfo_Void.Size(m)
}
func (m *Void) XXX_DiscardUnknown() {
	xxx_messageInfo_Void.DiscardUnknown(m)
}

var xxx_messageInfo_Void proto.InternalMessageInfo

// Refers to an offloaded set of files. It encapsulates the type of the store and a unique uri for where the data is.
// There are no restrictions on how the uri is formatted since it will depend on how to interact with the store.
type Blob struct {
	Metadata             *BlobMetadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	Uri                  string        `protobuf:"bytes,3,opt,name=uri,proto3" json:"uri,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Blob) Reset()         { *m = Blob{} }
func (m *Blob) String() string { return proto.CompactTextString(m) }
func (*Blob) ProtoMessage()    {}
func (*Blob) Descriptor() ([]byte, []int) {
	return fileDescriptor_literals_1ac04b6ab2b9b143, []int{1}
}
func (m *Blob) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Blob.Unmarshal(m, b)
}
func (m *Blob) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Blob.Marshal(b, m, deterministic)
}
func (dst *Blob) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Blob.Merge(dst, src)
}
func (m *Blob) XXX_Size() int {
	return xxx_messageInfo_Blob.Size(m)
}
func (m *Blob) XXX_DiscardUnknown() {
	xxx_messageInfo_Blob.DiscardUnknown(m)
}

var xxx_messageInfo_Blob proto.InternalMessageInfo

func (m *Blob) GetMetadata() *BlobMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Blob) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

type BlobMetadata struct {
	Type                 *BlobType `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *BlobMetadata) Reset()         { *m = BlobMetadata{} }
func (m *BlobMetadata) String() string { return proto.CompactTextString(m) }
func (*BlobMetadata) ProtoMessage()    {}
func (*BlobMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_literals_1ac04b6ab2b9b143, []int{2}
}
func (m *BlobMetadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BlobMetadata.Unmarshal(m, b)
}
func (m *BlobMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BlobMetadata.Marshal(b, m, deterministic)
}
func (dst *BlobMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlobMetadata.Merge(dst, src)
}
func (m *BlobMetadata) XXX_Size() int {
	return xxx_messageInfo_BlobMetadata.Size(m)
}
func (m *BlobMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_BlobMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_BlobMetadata proto.InternalMessageInfo

func (m *BlobMetadata) GetType() *BlobType {
	if m != nil {
		return m.Type
	}
	return nil
}

// A simple byte array with a tag to help different parts of the system communicate about what is in the byte array.
// It's strongly advisable that consumers of this type define a unique tag and validate the tag before parsing the data.
type Binary struct {
	Value                []byte   `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	Tag                  string   `protobuf:"bytes,2,opt,name=tag,proto3" json:"tag,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Binary) Reset()         { *m = Binary{} }
func (m *Binary) String() string { return proto.CompactTextString(m) }
func (*Binary) ProtoMessage()    {}
func (*Binary) Descriptor() ([]byte, []int) {
	return fileDescriptor_literals_1ac04b6ab2b9b143, []int{3}
}
func (m *Binary) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Binary.Unmarshal(m, b)
}
func (m *Binary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Binary.Marshal(b, m, deterministic)
}
func (dst *Binary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Binary.Merge(dst, src)
}
func (m *Binary) XXX_Size() int {
	return xxx_messageInfo_Binary.Size(m)
}
func (m *Binary) XXX_DiscardUnknown() {
	xxx_messageInfo_Binary.DiscardUnknown(m)
}

var xxx_messageInfo_Binary proto.InternalMessageInfo

func (m *Binary) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Binary) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

// A strongly typed schema that defines the interface of data retrieved from the underlying storage medium.
type Schema struct {
	Uri                  string      `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
	Type                 *SchemaType `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Schema) Reset()         { *m = Schema{} }
func (m *Schema) String() string { return proto.CompactTextString(m) }
func (*Schema) ProtoMessage()    {}
func (*Schema) Descriptor() ([]byte, []int) {
	return fileDescriptor_literals_1ac04b6ab2b9b143, []int{4}
}
func (m *Schema) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Schema.Unmarshal(m, b)
}
func (m *Schema) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Schema.Marshal(b, m, deterministic)
}
func (dst *Schema) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Schema.Merge(dst, src)
}
func (m *Schema) XXX_Size() int {
	return xxx_messageInfo_Schema.Size(m)
}
func (m *Schema) XXX_DiscardUnknown() {
	xxx_messageInfo_Schema.DiscardUnknown(m)
}

var xxx_messageInfo_Schema proto.InternalMessageInfo

func (m *Schema) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *Schema) GetType() *SchemaType {
	if m != nil {
		return m.Type
	}
	return nil
}

type Scalar struct {
	// Types that are valid to be assigned to Value:
	//	*Scalar_Primitive
	//	*Scalar_Blob
	//	*Scalar_Binary
	//	*Scalar_Schema
	//	*Scalar_NoneType
	//	*Scalar_Error
	//	*Scalar_Generic
	Value                isScalar_Value `protobuf_oneof:"value"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Scalar) Reset()         { *m = Scalar{} }
func (m *Scalar) String() string { return proto.CompactTextString(m) }
func (*Scalar) ProtoMessage()    {}
func (*Scalar) Descriptor() ([]byte, []int) {
	return fileDescriptor_literals_1ac04b6ab2b9b143, []int{5}
}
func (m *Scalar) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Scalar.Unmarshal(m, b)
}
func (m *Scalar) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Scalar.Marshal(b, m, deterministic)
}
func (dst *Scalar) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Scalar.Merge(dst, src)
}
func (m *Scalar) XXX_Size() int {
	return xxx_messageInfo_Scalar.Size(m)
}
func (m *Scalar) XXX_DiscardUnknown() {
	xxx_messageInfo_Scalar.DiscardUnknown(m)
}

var xxx_messageInfo_Scalar proto.InternalMessageInfo

type isScalar_Value interface {
	isScalar_Value()
}

type Scalar_Primitive struct {
	Primitive *Primitive `protobuf:"bytes,1,opt,name=primitive,proto3,oneof"`
}

type Scalar_Blob struct {
	Blob *Blob `protobuf:"bytes,2,opt,name=blob,proto3,oneof"`
}

type Scalar_Binary struct {
	Binary *Binary `protobuf:"bytes,3,opt,name=binary,proto3,oneof"`
}

type Scalar_Schema struct {
	Schema *Schema `protobuf:"bytes,4,opt,name=schema,proto3,oneof"`
}

type Scalar_NoneType struct {
	NoneType *Void `protobuf:"bytes,5,opt,name=none_type,json=noneType,proto3,oneof"`
}

type Scalar_Error struct {
	Error *Error `protobuf:"bytes,6,opt,name=error,proto3,oneof"`
}

type Scalar_Generic struct {
	Generic *_struct.Struct `protobuf:"bytes,7,opt,name=generic,proto3,oneof"`
}

func (*Scalar_Primitive) isScalar_Value() {}

func (*Scalar_Blob) isScalar_Value() {}

func (*Scalar_Binary) isScalar_Value() {}

func (*Scalar_Schema) isScalar_Value() {}

func (*Scalar_NoneType) isScalar_Value() {}

func (*Scalar_Error) isScalar_Value() {}

func (*Scalar_Generic) isScalar_Value() {}

func (m *Scalar) GetValue() isScalar_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Scalar) GetPrimitive() *Primitive {
	if x, ok := m.GetValue().(*Scalar_Primitive); ok {
		return x.Primitive
	}
	return nil
}

func (m *Scalar) GetBlob() *Blob {
	if x, ok := m.GetValue().(*Scalar_Blob); ok {
		return x.Blob
	}
	return nil
}

func (m *Scalar) GetBinary() *Binary {
	if x, ok := m.GetValue().(*Scalar_Binary); ok {
		return x.Binary
	}
	return nil
}

func (m *Scalar) GetSchema() *Schema {
	if x, ok := m.GetValue().(*Scalar_Schema); ok {
		return x.Schema
	}
	return nil
}

func (m *Scalar) GetNoneType() *Void {
	if x, ok := m.GetValue().(*Scalar_NoneType); ok {
		return x.NoneType
	}
	return nil
}

func (m *Scalar) GetError() *Error {
	if x, ok := m.GetValue().(*Scalar_Error); ok {
		return x.Error
	}
	return nil
}

func (m *Scalar) GetGeneric() *_struct.Struct {
	if x, ok := m.GetValue().(*Scalar_Generic); ok {
		return x.Generic
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Scalar) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Scalar_OneofMarshaler, _Scalar_OneofUnmarshaler, _Scalar_OneofSizer, []interface{}{
		(*Scalar_Primitive)(nil),
		(*Scalar_Blob)(nil),
		(*Scalar_Binary)(nil),
		(*Scalar_Schema)(nil),
		(*Scalar_NoneType)(nil),
		(*Scalar_Error)(nil),
		(*Scalar_Generic)(nil),
	}
}

func _Scalar_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Scalar)
	// value
	switch x := m.Value.(type) {
	case *Scalar_Primitive:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Primitive); err != nil {
			return err
		}
	case *Scalar_Blob:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Blob); err != nil {
			return err
		}
	case *Scalar_Binary:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Binary); err != nil {
			return err
		}
	case *Scalar_Schema:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Schema); err != nil {
			return err
		}
	case *Scalar_NoneType:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoneType); err != nil {
			return err
		}
	case *Scalar_Error:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case *Scalar_Generic:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Generic); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Scalar.Value has unexpected type %T", x)
	}
	return nil
}

func _Scalar_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Scalar)
	switch tag {
	case 1: // value.primitive
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Primitive)
		err := b.DecodeMessage(msg)
		m.Value = &Scalar_Primitive{msg}
		return true, err
	case 2: // value.blob
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Blob)
		err := b.DecodeMessage(msg)
		m.Value = &Scalar_Blob{msg}
		return true, err
	case 3: // value.binary
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Binary)
		err := b.DecodeMessage(msg)
		m.Value = &Scalar_Binary{msg}
		return true, err
	case 4: // value.schema
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Schema)
		err := b.DecodeMessage(msg)
		m.Value = &Scalar_Schema{msg}
		return true, err
	case 5: // value.none_type
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Void)
		err := b.DecodeMessage(msg)
		m.Value = &Scalar_NoneType{msg}
		return true, err
	case 6: // value.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error)
		err := b.DecodeMessage(msg)
		m.Value = &Scalar_Error{msg}
		return true, err
	case 7: // value.generic
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(_struct.Struct)
		err := b.DecodeMessage(msg)
		m.Value = &Scalar_Generic{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Scalar_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Scalar)
	// value
	switch x := m.Value.(type) {
	case *Scalar_Primitive:
		s := proto.Size(x.Primitive)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Scalar_Blob:
		s := proto.Size(x.Blob)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Scalar_Binary:
		s := proto.Size(x.Binary)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Scalar_Schema:
		s := proto.Size(x.Schema)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Scalar_NoneType:
		s := proto.Size(x.NoneType)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Scalar_Error:
		s := proto.Size(x.Error)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Scalar_Generic:
		s := proto.Size(x.Generic)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Represents a node closure that contain all required information to execute.
type Closure struct {
	// A node to execute. All inputs of the node must be statically bound in node input bindings. Dynamic bindings
	// is not yet supported.
	Node *Node `protobuf:"bytes,1,opt,name=node,proto3" json:"node,omitempty"`
	// [Optional] List of task specs directly or indirectly referenced in node. This list will take precedence over
	// other task specs found in the environment (e.g. in an enclosing workflow) when resolving task references.
	Tasks []*TaskTemplate `protobuf:"bytes,2,rep,name=tasks,proto3" json:"tasks,omitempty"`
	// [Optional] List of workflow specs directly or indirectly referenced in node. This list will take precedence over
	// other workflow specs found in the environment (e.g. in an enclosing workflow) when resolving workflows references.
	SubWorkflows         []*WorkflowTemplate `protobuf:"bytes,3,rep,name=sub_workflows,json=subWorkflows,proto3" json:"sub_workflows,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *Closure) Reset()         { *m = Closure{} }
func (m *Closure) String() string { return proto.CompactTextString(m) }
func (*Closure) ProtoMessage()    {}
func (*Closure) Descriptor() ([]byte, []int) {
	return fileDescriptor_literals_1ac04b6ab2b9b143, []int{6}
}
func (m *Closure) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Closure.Unmarshal(m, b)
}
func (m *Closure) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Closure.Marshal(b, m, deterministic)
}
func (dst *Closure) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Closure.Merge(dst, src)
}
func (m *Closure) XXX_Size() int {
	return xxx_messageInfo_Closure.Size(m)
}
func (m *Closure) XXX_DiscardUnknown() {
	xxx_messageInfo_Closure.DiscardUnknown(m)
}

var xxx_messageInfo_Closure proto.InternalMessageInfo

func (m *Closure) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *Closure) GetTasks() []*TaskTemplate {
	if m != nil {
		return m.Tasks
	}
	return nil
}

func (m *Closure) GetSubWorkflows() []*WorkflowTemplate {
	if m != nil {
		return m.SubWorkflows
	}
	return nil
}

// A simple value. This supports any level of nesting (e.g. array of array of array of Blobs) as well as simple primitives.
type Literal struct {
	// Types that are valid to be assigned to Value:
	//	*Literal_Scalar
	//	*Literal_Collection
	//	*Literal_Map
	//	*Literal_Closure
	Value                isLiteral_Value `protobuf_oneof:"value"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Literal) Reset()         { *m = Literal{} }
func (m *Literal) String() string { return proto.CompactTextString(m) }
func (*Literal) ProtoMessage()    {}
func (*Literal) Descriptor() ([]byte, []int) {
	return fileDescriptor_literals_1ac04b6ab2b9b143, []int{7}
}
func (m *Literal) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Literal.Unmarshal(m, b)
}
func (m *Literal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Literal.Marshal(b, m, deterministic)
}
func (dst *Literal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Literal.Merge(dst, src)
}
func (m *Literal) XXX_Size() int {
	return xxx_messageInfo_Literal.Size(m)
}
func (m *Literal) XXX_DiscardUnknown() {
	xxx_messageInfo_Literal.DiscardUnknown(m)
}

var xxx_messageInfo_Literal proto.InternalMessageInfo

type isLiteral_Value interface {
	isLiteral_Value()
}

type Literal_Scalar struct {
	Scalar *Scalar `protobuf:"bytes,1,opt,name=scalar,proto3,oneof"`
}

type Literal_Collection struct {
	Collection *LiteralCollection `protobuf:"bytes,2,opt,name=collection,proto3,oneof"`
}

type Literal_Map struct {
	Map *LiteralMap `protobuf:"bytes,3,opt,name=map,proto3,oneof"`
}

type Literal_Closure struct {
	Closure *Closure `protobuf:"bytes,4,opt,name=closure,proto3,oneof"`
}

func (*Literal_Scalar) isLiteral_Value() {}

func (*Literal_Collection) isLiteral_Value() {}

func (*Literal_Map) isLiteral_Value() {}

func (*Literal_Closure) isLiteral_Value() {}

func (m *Literal) GetValue() isLiteral_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Literal) GetScalar() *Scalar {
	if x, ok := m.GetValue().(*Literal_Scalar); ok {
		return x.Scalar
	}
	return nil
}

func (m *Literal) GetCollection() *LiteralCollection {
	if x, ok := m.GetValue().(*Literal_Collection); ok {
		return x.Collection
	}
	return nil
}

func (m *Literal) GetMap() *LiteralMap {
	if x, ok := m.GetValue().(*Literal_Map); ok {
		return x.Map
	}
	return nil
}

func (m *Literal) GetClosure() *Closure {
	if x, ok := m.GetValue().(*Literal_Closure); ok {
		return x.Closure
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Literal) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Literal_OneofMarshaler, _Literal_OneofUnmarshaler, _Literal_OneofSizer, []interface{}{
		(*Literal_Scalar)(nil),
		(*Literal_Collection)(nil),
		(*Literal_Map)(nil),
		(*Literal_Closure)(nil),
	}
}

func _Literal_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Literal)
	// value
	switch x := m.Value.(type) {
	case *Literal_Scalar:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Scalar); err != nil {
			return err
		}
	case *Literal_Collection:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Collection); err != nil {
			return err
		}
	case *Literal_Map:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Map); err != nil {
			return err
		}
	case *Literal_Closure:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Closure); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Literal.Value has unexpected type %T", x)
	}
	return nil
}

func _Literal_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Literal)
	switch tag {
	case 1: // value.scalar
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Scalar)
		err := b.DecodeMessage(msg)
		m.Value = &Literal_Scalar{msg}
		return true, err
	case 2: // value.collection
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LiteralCollection)
		err := b.DecodeMessage(msg)
		m.Value = &Literal_Collection{msg}
		return true, err
	case 3: // value.map
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LiteralMap)
		err := b.DecodeMessage(msg)
		m.Value = &Literal_Map{msg}
		return true, err
	case 4: // value.closure
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Closure)
		err := b.DecodeMessage(msg)
		m.Value = &Literal_Closure{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Literal_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Literal)
	// value
	switch x := m.Value.(type) {
	case *Literal_Scalar:
		s := proto.Size(x.Scalar)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Literal_Collection:
		s := proto.Size(x.Collection)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Literal_Map:
		s := proto.Size(x.Map)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Literal_Closure:
		s := proto.Size(x.Closure)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A collection of literals. This is a workaround since oneofs in proto messages cannot contain a repeated field.
type LiteralCollection struct {
	Literals             []*Literal `protobuf:"bytes,1,rep,name=literals,proto3" json:"literals,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *LiteralCollection) Reset()         { *m = LiteralCollection{} }
func (m *LiteralCollection) String() string { return proto.CompactTextString(m) }
func (*LiteralCollection) ProtoMessage()    {}
func (*LiteralCollection) Descriptor() ([]byte, []int) {
	return fileDescriptor_literals_1ac04b6ab2b9b143, []int{8}
}
func (m *LiteralCollection) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LiteralCollection.Unmarshal(m, b)
}
func (m *LiteralCollection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LiteralCollection.Marshal(b, m, deterministic)
}
func (dst *LiteralCollection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiteralCollection.Merge(dst, src)
}
func (m *LiteralCollection) XXX_Size() int {
	return xxx_messageInfo_LiteralCollection.Size(m)
}
func (m *LiteralCollection) XXX_DiscardUnknown() {
	xxx_messageInfo_LiteralCollection.DiscardUnknown(m)
}

var xxx_messageInfo_LiteralCollection proto.InternalMessageInfo

func (m *LiteralCollection) GetLiterals() []*Literal {
	if m != nil {
		return m.Literals
	}
	return nil
}

// A map of literals. This is a workaround since oneofs in proto messages cannot contain a repeated field.
type LiteralMap struct {
	Literals             map[string]*Literal `protobuf:"bytes,1,rep,name=literals,proto3" json:"literals,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *LiteralMap) Reset()         { *m = LiteralMap{} }
func (m *LiteralMap) String() string { return proto.CompactTextString(m) }
func (*LiteralMap) ProtoMessage()    {}
func (*LiteralMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_literals_1ac04b6ab2b9b143, []int{9}
}
func (m *LiteralMap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LiteralMap.Unmarshal(m, b)
}
func (m *LiteralMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LiteralMap.Marshal(b, m, deterministic)
}
func (dst *LiteralMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiteralMap.Merge(dst, src)
}
func (m *LiteralMap) XXX_Size() int {
	return xxx_messageInfo_LiteralMap.Size(m)
}
func (m *LiteralMap) XXX_DiscardUnknown() {
	xxx_messageInfo_LiteralMap.DiscardUnknown(m)
}

var xxx_messageInfo_LiteralMap proto.InternalMessageInfo

func (m *LiteralMap) GetLiterals() map[string]*Literal {
	if m != nil {
		return m.Literals
	}
	return nil
}

// A collection of BindingData items.
type BindingDataCollection struct {
	Bindings             []*BindingData `protobuf:"bytes,1,rep,name=bindings,proto3" json:"bindings,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *BindingDataCollection) Reset()         { *m = BindingDataCollection{} }
func (m *BindingDataCollection) String() string { return proto.CompactTextString(m) }
func (*BindingDataCollection) ProtoMessage()    {}
func (*BindingDataCollection) Descriptor() ([]byte, []int) {
	return fileDescriptor_literals_1ac04b6ab2b9b143, []int{10}
}
func (m *BindingDataCollection) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BindingDataCollection.Unmarshal(m, b)
}
func (m *BindingDataCollection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BindingDataCollection.Marshal(b, m, deterministic)
}
func (dst *BindingDataCollection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BindingDataCollection.Merge(dst, src)
}
func (m *BindingDataCollection) XXX_Size() int {
	return xxx_messageInfo_BindingDataCollection.Size(m)
}
func (m *BindingDataCollection) XXX_DiscardUnknown() {
	xxx_messageInfo_BindingDataCollection.DiscardUnknown(m)
}

var xxx_messageInfo_BindingDataCollection proto.InternalMessageInfo

func (m *BindingDataCollection) GetBindings() []*BindingData {
	if m != nil {
		return m.Bindings
	}
	return nil
}

// A map of BindingData items.
type BindingDataMap struct {
	Bindings             map[string]*BindingData `protobuf:"bytes,1,rep,name=bindings,proto3" json:"bindings,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *BindingDataMap) Reset()         { *m = BindingDataMap{} }
func (m *BindingDataMap) String() string { return proto.CompactTextString(m) }
func (*BindingDataMap) ProtoMessage()    {}
func (*BindingDataMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_literals_1ac04b6ab2b9b143, []int{11}
}
func (m *BindingDataMap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BindingDataMap.Unmarshal(m, b)
}
func (m *BindingDataMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BindingDataMap.Marshal(b, m, deterministic)
}
func (dst *BindingDataMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BindingDataMap.Merge(dst, src)
}
func (m *BindingDataMap) XXX_Size() int {
	return xxx_messageInfo_BindingDataMap.Size(m)
}
func (m *BindingDataMap) XXX_DiscardUnknown() {
	xxx_messageInfo_BindingDataMap.DiscardUnknown(m)
}

var xxx_messageInfo_BindingDataMap proto.InternalMessageInfo

func (m *BindingDataMap) GetBindings() map[string]*BindingData {
	if m != nil {
		return m.Bindings
	}
	return nil
}

// Specifies either a simple value or a reference to another output.
type BindingData struct {
	// Types that are valid to be assigned to Value:
	//	*BindingData_Scalar
	//	*BindingData_Collection
	//	*BindingData_Promise
	//	*BindingData_Map
	//	*BindingData_Closure
	Value                isBindingData_Value `protobuf_oneof:"value"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *BindingData) Reset()         { *m = BindingData{} }
func (m *BindingData) String() string { return proto.CompactTextString(m) }
func (*BindingData) ProtoMessage()    {}
func (*BindingData) Descriptor() ([]byte, []int) {
	return fileDescriptor_literals_1ac04b6ab2b9b143, []int{12}
}
func (m *BindingData) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BindingData.Unmarshal(m, b)
}
func (m *BindingData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BindingData.Marshal(b, m, deterministic)
}
func (dst *BindingData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BindingData.Merge(dst, src)
}
func (m *BindingData) XXX_Size() int {
	return xxx_messageInfo_BindingData.Size(m)
}
func (m *BindingData) XXX_DiscardUnknown() {
	xxx_messageInfo_BindingData.DiscardUnknown(m)
}

var xxx_messageInfo_BindingData proto.InternalMessageInfo

type isBindingData_Value interface {
	isBindingData_Value()
}

type BindingData_Scalar struct {
	Scalar *Scalar `protobuf:"bytes,1,opt,name=scalar,proto3,oneof"`
}

type BindingData_Collection struct {
	Collection *BindingDataCollection `protobuf:"bytes,2,opt,name=collection,proto3,oneof"`
}

type BindingData_Promise struct {
	Promise *OutputReference `protobuf:"bytes,3,opt,name=promise,proto3,oneof"`
}

type BindingData_Map struct {
	Map *BindingDataMap `protobuf:"bytes,4,opt,name=map,proto3,oneof"`
}

type BindingData_Closure struct {
	Closure *Closure `protobuf:"bytes,5,opt,name=closure,proto3,oneof"`
}

func (*BindingData_Scalar) isBindingData_Value() {}

func (*BindingData_Collection) isBindingData_Value() {}

func (*BindingData_Promise) isBindingData_Value() {}

func (*BindingData_Map) isBindingData_Value() {}

func (*BindingData_Closure) isBindingData_Value() {}

func (m *BindingData) GetValue() isBindingData_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *BindingData) GetScalar() *Scalar {
	if x, ok := m.GetValue().(*BindingData_Scalar); ok {
		return x.Scalar
	}
	return nil
}

func (m *BindingData) GetCollection() *BindingDataCollection {
	if x, ok := m.GetValue().(*BindingData_Collection); ok {
		return x.Collection
	}
	return nil
}

func (m *BindingData) GetPromise() *OutputReference {
	if x, ok := m.GetValue().(*BindingData_Promise); ok {
		return x.Promise
	}
	return nil
}

func (m *BindingData) GetMap() *BindingDataMap {
	if x, ok := m.GetValue().(*BindingData_Map); ok {
		return x.Map
	}
	return nil
}

func (m *BindingData) GetClosure() *Closure {
	if x, ok := m.GetValue().(*BindingData_Closure); ok {
		return x.Closure
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*BindingData) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _BindingData_OneofMarshaler, _BindingData_OneofUnmarshaler, _BindingData_OneofSizer, []interface{}{
		(*BindingData_Scalar)(nil),
		(*BindingData_Collection)(nil),
		(*BindingData_Promise)(nil),
		(*BindingData_Map)(nil),
		(*BindingData_Closure)(nil),
	}
}

func _BindingData_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*BindingData)
	// value
	switch x := m.Value.(type) {
	case *BindingData_Scalar:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Scalar); err != nil {
			return err
		}
	case *BindingData_Collection:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Collection); err != nil {
			return err
		}
	case *BindingData_Promise:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Promise); err != nil {
			return err
		}
	case *BindingData_Map:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Map); err != nil {
			return err
		}
	case *BindingData_Closure:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Closure); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("BindingData.Value has unexpected type %T", x)
	}
	return nil
}

func _BindingData_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*BindingData)
	switch tag {
	case 1: // value.scalar
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Scalar)
		err := b.DecodeMessage(msg)
		m.Value = &BindingData_Scalar{msg}
		return true, err
	case 2: // value.collection
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BindingDataCollection)
		err := b.DecodeMessage(msg)
		m.Value = &BindingData_Collection{msg}
		return true, err
	case 3: // value.promise
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(OutputReference)
		err := b.DecodeMessage(msg)
		m.Value = &BindingData_Promise{msg}
		return true, err
	case 4: // value.map
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BindingDataMap)
		err := b.DecodeMessage(msg)
		m.Value = &BindingData_Map{msg}
		return true, err
	case 5: // value.closure
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Closure)
		err := b.DecodeMessage(msg)
		m.Value = &BindingData_Closure{msg}
		return true, err
	default:
		return false, nil
	}
}

func _BindingData_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*BindingData)
	// value
	switch x := m.Value.(type) {
	case *BindingData_Scalar:
		s := proto.Size(x.Scalar)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *BindingData_Collection:
		s := proto.Size(x.Collection)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *BindingData_Promise:
		s := proto.Size(x.Promise)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *BindingData_Map:
		s := proto.Size(x.Map)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *BindingData_Closure:
		s := proto.Size(x.Closure)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// An input/output binding of a variable to either static value or a node output.
type Binding struct {
	// Variable name must match an input/output variable of the node.
	Var string `protobuf:"bytes,1,opt,name=var,proto3" json:"var,omitempty"`
	// Data to use to bind this variable.
	Binding              *BindingData `protobuf:"bytes,2,opt,name=binding,proto3" json:"binding,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Binding) Reset()         { *m = Binding{} }
func (m *Binding) String() string { return proto.CompactTextString(m) }
func (*Binding) ProtoMessage()    {}
func (*Binding) Descriptor() ([]byte, []int) {
	return fileDescriptor_literals_1ac04b6ab2b9b143, []int{13}
}
func (m *Binding) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Binding.Unmarshal(m, b)
}
func (m *Binding) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Binding.Marshal(b, m, deterministic)
}
func (dst *Binding) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Binding.Merge(dst, src)
}
func (m *Binding) XXX_Size() int {
	return xxx_messageInfo_Binding.Size(m)
}
func (m *Binding) XXX_DiscardUnknown() {
	xxx_messageInfo_Binding.DiscardUnknown(m)
}

var xxx_messageInfo_Binding proto.InternalMessageInfo

func (m *Binding) GetVar() string {
	if m != nil {
		return m.Var
	}
	return ""
}

func (m *Binding) GetBinding() *BindingData {
	if m != nil {
		return m.Binding
	}
	return nil
}

// Defines a condition and the execution unit that should be executed if the condition is satisfied.
type IfBlock struct {
	Condition            *BooleanExpression `protobuf:"bytes,1,opt,name=condition,proto3" json:"condition,omitempty"`
	ThenNode             *Node              `protobuf:"bytes,2,opt,name=then_node,json=thenNode,proto3" json:"then_node,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *IfBlock) Reset()         { *m = IfBlock{} }
func (m *IfBlock) String() string { return proto.CompactTextString(m) }
func (*IfBlock) ProtoMessage()    {}
func (*IfBlock) Descriptor() ([]byte, []int) {
	return fileDescriptor_literals_1ac04b6ab2b9b143, []int{14}
}
func (m *IfBlock) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IfBlock.Unmarshal(m, b)
}
func (m *IfBlock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IfBlock.Marshal(b, m, deterministic)
}
func (dst *IfBlock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IfBlock.Merge(dst, src)
}
func (m *IfBlock) XXX_Size() int {
	return xxx_messageInfo_IfBlock.Size(m)
}
func (m *IfBlock) XXX_DiscardUnknown() {
	xxx_messageInfo_IfBlock.DiscardUnknown(m)
}

var xxx_messageInfo_IfBlock proto.InternalMessageInfo

func (m *IfBlock) GetCondition() *BooleanExpression {
	if m != nil {
		return m.Condition
	}
	return nil
}

func (m *IfBlock) GetThenNode() *Node {
	if m != nil {
		return m.ThenNode
	}
	return nil
}

// Defines a series of if/else blocks. The first branch whose condition evaluates to true is the one to execute.
// If no conditions were satisfied, the else_node or the error will execute.
type IfElseBlock struct {
	// +required. First condition to evaluate.
	Case *IfBlock `protobuf:"bytes,1,opt,name=case,proto3" json:"case,omitempty"`
	// +optional. Additional branches to evaluate.
	Other []*IfBlock `protobuf:"bytes,2,rep,name=other,proto3" json:"other,omitempty"`
	// +required.
	//
	// Types that are valid to be assigned to Default:
	//	*IfElseBlock_ElseNode
	//	*IfElseBlock_Error
	Default              isIfElseBlock_Default `protobuf_oneof:"default"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *IfElseBlock) Reset()         { *m = IfElseBlock{} }
func (m *IfElseBlock) String() string { return proto.CompactTextString(m) }
func (*IfElseBlock) ProtoMessage()    {}
func (*IfElseBlock) Descriptor() ([]byte, []int) {
	return fileDescriptor_literals_1ac04b6ab2b9b143, []int{15}
}
func (m *IfElseBlock) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IfElseBlock.Unmarshal(m, b)
}
func (m *IfElseBlock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IfElseBlock.Marshal(b, m, deterministic)
}
func (dst *IfElseBlock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IfElseBlock.Merge(dst, src)
}
func (m *IfElseBlock) XXX_Size() int {
	return xxx_messageInfo_IfElseBlock.Size(m)
}
func (m *IfElseBlock) XXX_DiscardUnknown() {
	xxx_messageInfo_IfElseBlock.DiscardUnknown(m)
}

var xxx_messageInfo_IfElseBlock proto.InternalMessageInfo

func (m *IfElseBlock) GetCase() *IfBlock {
	if m != nil {
		return m.Case
	}
	return nil
}

func (m *IfElseBlock) GetOther() []*IfBlock {
	if m != nil {
		return m.Other
	}
	return nil
}

type isIfElseBlock_Default interface {
	isIfElseBlock_Default()
}

type IfElseBlock_ElseNode struct {
	ElseNode *Node `protobuf:"bytes,3,opt,name=else_node,json=elseNode,proto3,oneof"`
}

type IfElseBlock_Error struct {
	Error *Error `protobuf:"bytes,4,opt,name=error,proto3,oneof"`
}

func (*IfElseBlock_ElseNode) isIfElseBlock_Default() {}

func (*IfElseBlock_Error) isIfElseBlock_Default() {}

func (m *IfElseBlock) GetDefault() isIfElseBlock_Default {
	if m != nil {
		return m.Default
	}
	return nil
}

func (m *IfElseBlock) GetElseNode() *Node {
	if x, ok := m.GetDefault().(*IfElseBlock_ElseNode); ok {
		return x.ElseNode
	}
	return nil
}

func (m *IfElseBlock) GetError() *Error {
	if x, ok := m.GetDefault().(*IfElseBlock_Error); ok {
		return x.Error
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*IfElseBlock) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _IfElseBlock_OneofMarshaler, _IfElseBlock_OneofUnmarshaler, _IfElseBlock_OneofSizer, []interface{}{
		(*IfElseBlock_ElseNode)(nil),
		(*IfElseBlock_Error)(nil),
	}
}

func _IfElseBlock_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*IfElseBlock)
	// default
	switch x := m.Default.(type) {
	case *IfElseBlock_ElseNode:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ElseNode); err != nil {
			return err
		}
	case *IfElseBlock_Error:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("IfElseBlock.Default has unexpected type %T", x)
	}
	return nil
}

func _IfElseBlock_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*IfElseBlock)
	switch tag {
	case 3: // default.else_node
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Node)
		err := b.DecodeMessage(msg)
		m.Default = &IfElseBlock_ElseNode{msg}
		return true, err
	case 4: // default.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error)
		err := b.DecodeMessage(msg)
		m.Default = &IfElseBlock_Error{msg}
		return true, err
	default:
		return false, nil
	}
}

func _IfElseBlock_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*IfElseBlock)
	// default
	switch x := m.Default.(type) {
	case *IfElseBlock_ElseNode:
		s := proto.Size(x.ElseNode)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *IfElseBlock_Error:
		s := proto.Size(x.Error)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// BranchNode is a special node that alter the flow of the workflow graph. It allows the control flow to branch at
// runtime based on a series of conditions that get evaluated on various parameters (e.g. inputs, primtives).
type BranchNode struct {
	// +required
	IfElse               *IfElseBlock `protobuf:"bytes,1,opt,name=if_else,json=ifElse,proto3" json:"if_else,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *BranchNode) Reset()         { *m = BranchNode{} }
func (m *BranchNode) String() string { return proto.CompactTextString(m) }
func (*BranchNode) ProtoMessage()    {}
func (*BranchNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_literals_1ac04b6ab2b9b143, []int{16}
}
func (m *BranchNode) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BranchNode.Unmarshal(m, b)
}
func (m *BranchNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BranchNode.Marshal(b, m, deterministic)
}
func (dst *BranchNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BranchNode.Merge(dst, src)
}
func (m *BranchNode) XXX_Size() int {
	return xxx_messageInfo_BranchNode.Size(m)
}
func (m *BranchNode) XXX_DiscardUnknown() {
	xxx_messageInfo_BranchNode.DiscardUnknown(m)
}

var xxx_messageInfo_BranchNode proto.InternalMessageInfo

func (m *BranchNode) GetIfElse() *IfElseBlock {
	if m != nil {
		return m.IfElse
	}
	return nil
}

// A specialized node type that expects a Closure as an additional input called "input_closure". Other inputs bound
// will be passed down to the closure if it expects any, otherwise additional inputs will be ignored.
type ClosureNode struct {
	// The closure type to expect to be bound to "input_closure" input for this node. ClosureType interface must be
	// populated if inputs/outputs are expected to be passed to and consumed from, respectively, the executed closure.
	ClosureType          *ClosureType `protobuf:"bytes,1,opt,name=closure_type,json=closureType,proto3" json:"closure_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ClosureNode) Reset()         { *m = ClosureNode{} }
func (m *ClosureNode) String() string { return proto.CompactTextString(m) }
func (*ClosureNode) ProtoMessage()    {}
func (*ClosureNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_literals_1ac04b6ab2b9b143, []int{17}
}
func (m *ClosureNode) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ClosureNode.Unmarshal(m, b)
}
func (m *ClosureNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ClosureNode.Marshal(b, m, deterministic)
}
func (dst *ClosureNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClosureNode.Merge(dst, src)
}
func (m *ClosureNode) XXX_Size() int {
	return xxx_messageInfo_ClosureNode.Size(m)
}
func (m *ClosureNode) XXX_DiscardUnknown() {
	xxx_messageInfo_ClosureNode.DiscardUnknown(m)
}

var xxx_messageInfo_ClosureNode proto.InternalMessageInfo

func (m *ClosureNode) GetClosureType() *ClosureType {
	if m != nil {
		return m.ClosureType
	}
	return nil
}

// Refers to the task that the Node is to execute.
type TaskNode struct {
	// Types that are valid to be assigned to Reference:
	//	*TaskNode_ReferenceId
	Reference            isTaskNode_Reference `protobuf_oneof:"reference"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *TaskNode) Reset()         { *m = TaskNode{} }
func (m *TaskNode) String() string { return proto.CompactTextString(m) }
func (*TaskNode) ProtoMessage()    {}
func (*TaskNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_literals_1ac04b6ab2b9b143, []int{18}
}
func (m *TaskNode) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TaskNode.Unmarshal(m, b)
}
func (m *TaskNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TaskNode.Marshal(b, m, deterministic)
}
func (dst *TaskNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskNode.Merge(dst, src)
}
func (m *TaskNode) XXX_Size() int {
	return xxx_messageInfo_TaskNode.Size(m)
}
func (m *TaskNode) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskNode.DiscardUnknown(m)
}

var xxx_messageInfo_TaskNode proto.InternalMessageInfo

type isTaskNode_Reference interface {
	isTaskNode_Reference()
}

type TaskNode_ReferenceId struct {
	ReferenceId *Identifier `protobuf:"bytes,1,opt,name=reference_id,json=referenceId,proto3,oneof"`
}

func (*TaskNode_ReferenceId) isTaskNode_Reference() {}

func (m *TaskNode) GetReference() isTaskNode_Reference {
	if m != nil {
		return m.Reference
	}
	return nil
}

func (m *TaskNode) GetReferenceId() *Identifier {
	if x, ok := m.GetReference().(*TaskNode_ReferenceId); ok {
		return x.ReferenceId
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TaskNode) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TaskNode_OneofMarshaler, _TaskNode_OneofUnmarshaler, _TaskNode_OneofSizer, []interface{}{
		(*TaskNode_ReferenceId)(nil),
	}
}

func _TaskNode_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TaskNode)
	// reference
	switch x := m.Reference.(type) {
	case *TaskNode_ReferenceId:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ReferenceId); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TaskNode.Reference has unexpected type %T", x)
	}
	return nil
}

func _TaskNode_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TaskNode)
	switch tag {
	case 1: // reference.reference_id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Identifier)
		err := b.DecodeMessage(msg)
		m.Reference = &TaskNode_ReferenceId{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TaskNode_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TaskNode)
	// reference
	switch x := m.Reference.(type) {
	case *TaskNode_ReferenceId:
		s := proto.Size(x.ReferenceId)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Refers to a the workflow the node is to execute.
type WorkflowNode struct {
	// Types that are valid to be assigned to Reference:
	//	*WorkflowNode_LaunchplanRef
	//	*WorkflowNode_SubWorkflowRef
	Reference            isWorkflowNode_Reference `protobuf_oneof:"reference"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *WorkflowNode) Reset()         { *m = WorkflowNode{} }
func (m *WorkflowNode) String() string { return proto.CompactTextString(m) }
func (*WorkflowNode) ProtoMessage()    {}
func (*WorkflowNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_literals_1ac04b6ab2b9b143, []int{19}
}
func (m *WorkflowNode) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WorkflowNode.Unmarshal(m, b)
}
func (m *WorkflowNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WorkflowNode.Marshal(b, m, deterministic)
}
func (dst *WorkflowNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowNode.Merge(dst, src)
}
func (m *WorkflowNode) XXX_Size() int {
	return xxx_messageInfo_WorkflowNode.Size(m)
}
func (m *WorkflowNode) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowNode.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowNode proto.InternalMessageInfo

type isWorkflowNode_Reference interface {
	isWorkflowNode_Reference()
}

type WorkflowNode_LaunchplanRef struct {
	LaunchplanRef *Identifier `protobuf:"bytes,1,opt,name=launchplan_ref,json=launchplanRef,proto3,oneof"`
}

type WorkflowNode_SubWorkflowRef struct {
	SubWorkflowRef *Identifier `protobuf:"bytes,2,opt,name=sub_workflow_ref,json=subWorkflowRef,proto3,oneof"`
}

func (*WorkflowNode_LaunchplanRef) isWorkflowNode_Reference() {}

func (*WorkflowNode_SubWorkflowRef) isWorkflowNode_Reference() {}

func (m *WorkflowNode) GetReference() isWorkflowNode_Reference {
	if m != nil {
		return m.Reference
	}
	return nil
}

func (m *WorkflowNode) GetLaunchplanRef() *Identifier {
	if x, ok := m.GetReference().(*WorkflowNode_LaunchplanRef); ok {
		return x.LaunchplanRef
	}
	return nil
}

func (m *WorkflowNode) GetSubWorkflowRef() *Identifier {
	if x, ok := m.GetReference().(*WorkflowNode_SubWorkflowRef); ok {
		return x.SubWorkflowRef
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*WorkflowNode) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _WorkflowNode_OneofMarshaler, _WorkflowNode_OneofUnmarshaler, _WorkflowNode_OneofSizer, []interface{}{
		(*WorkflowNode_LaunchplanRef)(nil),
		(*WorkflowNode_SubWorkflowRef)(nil),
	}
}

func _WorkflowNode_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*WorkflowNode)
	// reference
	switch x := m.Reference.(type) {
	case *WorkflowNode_LaunchplanRef:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LaunchplanRef); err != nil {
			return err
		}
	case *WorkflowNode_SubWorkflowRef:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SubWorkflowRef); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("WorkflowNode.Reference has unexpected type %T", x)
	}
	return nil
}

func _WorkflowNode_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*WorkflowNode)
	switch tag {
	case 1: // reference.launchplan_ref
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Identifier)
		err := b.DecodeMessage(msg)
		m.Reference = &WorkflowNode_LaunchplanRef{msg}
		return true, err
	case 2: // reference.sub_workflow_ref
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Identifier)
		err := b.DecodeMessage(msg)
		m.Reference = &WorkflowNode_SubWorkflowRef{msg}
		return true, err
	default:
		return false, nil
	}
}

func _WorkflowNode_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*WorkflowNode)
	// reference
	switch x := m.Reference.(type) {
	case *WorkflowNode_LaunchplanRef:
		s := proto.Size(x.LaunchplanRef)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *WorkflowNode_SubWorkflowRef:
		s := proto.Size(x.SubWorkflowRef)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Defines extra information about the Node.
type NodeMetadata struct {
	// A friendly name for the Node
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The overall timeout of a task.
	Timeout *duration.Duration `protobuf:"bytes,4,opt,name=timeout,proto3" json:"timeout,omitempty"`
	// Number of retries per task.
	Retries              *RetryStrategy `protobuf:"bytes,5,opt,name=retries,proto3" json:"retries,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *NodeMetadata) Reset()         { *m = NodeMetadata{} }
func (m *NodeMetadata) String() string { return proto.CompactTextString(m) }
func (*NodeMetadata) ProtoMessage()    {}
func (*NodeMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_literals_1ac04b6ab2b9b143, []int{20}
}
func (m *NodeMetadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NodeMetadata.Unmarshal(m, b)
}
func (m *NodeMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NodeMetadata.Marshal(b, m, deterministic)
}
func (dst *NodeMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeMetadata.Merge(dst, src)
}
func (m *NodeMetadata) XXX_Size() int {
	return xxx_messageInfo_NodeMetadata.Size(m)
}
func (m *NodeMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_NodeMetadata proto.InternalMessageInfo

func (m *NodeMetadata) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NodeMetadata) GetTimeout() *duration.Duration {
	if m != nil {
		return m.Timeout
	}
	return nil
}

func (m *NodeMetadata) GetRetries() *RetryStrategy {
	if m != nil {
		return m.Retries
	}
	return nil
}

// Links a variable to an alias.
type Alias struct {
	// Must match one of the output variable names on a node.
	Var string `protobuf:"bytes,1,opt,name=var,proto3" json:"var,omitempty"`
	// A workflow-level unique alias that downstream nodes can refer to in their input.
	Alias                string   `protobuf:"bytes,2,opt,name=alias,proto3" json:"alias,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Alias) Reset()         { *m = Alias{} }
func (m *Alias) String() string { return proto.CompactTextString(m) }
func (*Alias) ProtoMessage()    {}
func (*Alias) Descriptor() ([]byte, []int) {
	return fileDescriptor_literals_1ac04b6ab2b9b143, []int{21}
}
func (m *Alias) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Alias.Unmarshal(m, b)
}
func (m *Alias) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Alias.Marshal(b, m, deterministic)
}
func (dst *Alias) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Alias.Merge(dst, src)
}
func (m *Alias) XXX_Size() int {
	return xxx_messageInfo_Alias.Size(m)
}
func (m *Alias) XXX_DiscardUnknown() {
	xxx_messageInfo_Alias.DiscardUnknown(m)
}

var xxx_messageInfo_Alias proto.InternalMessageInfo

func (m *Alias) GetVar() string {
	if m != nil {
		return m.Var
	}
	return ""
}

func (m *Alias) GetAlias() string {
	if m != nil {
		return m.Alias
	}
	return ""
}

// A Workflow graph Node. One unit of execution in the graph. Each node can be linked to a Task, a Workflow or a branch
// node.
type Node struct {
	// A workflow-level unique identifier that identifies this node in the workflow. "inputs" and "outputs" are reserved
	// node ids that cannot be used by other nodes.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Extra metadata about the node.
	Metadata *NodeMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Specifies how to bind the underlying interface's inputs. All required inputs specified in the underlying interface
	// must be fullfilled.
	Inputs []*Binding `protobuf:"bytes,3,rep,name=inputs,proto3" json:"inputs,omitempty"`
	// +optional Specifies execution depdendency for this node ensuring it will only get scheduled to run after all its
	// upstream nodes have completed. This node will have an implicit depdendency on any node that appears in inputs
	// field.
	UpstreamNodeIds []string `protobuf:"bytes,4,rep,name=upstream_node_ids,json=upstreamNodeIds,proto3" json:"upstream_node_ids,omitempty"`
	// +optional. A node can define aliases for a subset of its outputs. This is particularly useful if different nodes
	// need to conform to the same interface (e.g. all branches in a branch node). Downstream nodes must refer to this
	// nodes outputs using the alias if one's specified.
	OutputAliases []*Alias `protobuf:"bytes,5,rep,name=output_aliases,json=outputAliases,proto3" json:"output_aliases,omitempty"`
	// Information about the target to execute in this node.
	//
	// Types that are valid to be assigned to Target:
	//	*Node_TaskNode
	//	*Node_WorkflowNode
	//	*Node_BranchNode
	//	*Node_ClosureNode
	Target               isNode_Target `protobuf_oneof:"target"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_literals_1ac04b6ab2b9b143, []int{22}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Node.Unmarshal(m, b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Node.Marshal(b, m, deterministic)
}
func (dst *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(dst, src)
}
func (m *Node) XXX_Size() int {
	return xxx_messageInfo_Node.Size(m)
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

func (m *Node) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Node) GetMetadata() *NodeMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Node) GetInputs() []*Binding {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *Node) GetUpstreamNodeIds() []string {
	if m != nil {
		return m.UpstreamNodeIds
	}
	return nil
}

func (m *Node) GetOutputAliases() []*Alias {
	if m != nil {
		return m.OutputAliases
	}
	return nil
}

type isNode_Target interface {
	isNode_Target()
}

type Node_TaskNode struct {
	TaskNode *TaskNode `protobuf:"bytes,6,opt,name=task_node,json=taskNode,proto3,oneof"`
}

type Node_WorkflowNode struct {
	WorkflowNode *WorkflowNode `protobuf:"bytes,7,opt,name=workflow_node,json=workflowNode,proto3,oneof"`
}

type Node_BranchNode struct {
	BranchNode *BranchNode `protobuf:"bytes,8,opt,name=branch_node,json=branchNode,proto3,oneof"`
}

type Node_ClosureNode struct {
	ClosureNode *ClosureNode `protobuf:"bytes,9,opt,name=closure_node,json=closureNode,proto3,oneof"`
}

func (*Node_TaskNode) isNode_Target() {}

func (*Node_WorkflowNode) isNode_Target() {}

func (*Node_BranchNode) isNode_Target() {}

func (*Node_ClosureNode) isNode_Target() {}

func (m *Node) GetTarget() isNode_Target {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *Node) GetTaskNode() *TaskNode {
	if x, ok := m.GetTarget().(*Node_TaskNode); ok {
		return x.TaskNode
	}
	return nil
}

func (m *Node) GetWorkflowNode() *WorkflowNode {
	if x, ok := m.GetTarget().(*Node_WorkflowNode); ok {
		return x.WorkflowNode
	}
	return nil
}

func (m *Node) GetBranchNode() *BranchNode {
	if x, ok := m.GetTarget().(*Node_BranchNode); ok {
		return x.BranchNode
	}
	return nil
}

func (m *Node) GetClosureNode() *ClosureNode {
	if x, ok := m.GetTarget().(*Node_ClosureNode); ok {
		return x.ClosureNode
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Node) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Node_OneofMarshaler, _Node_OneofUnmarshaler, _Node_OneofSizer, []interface{}{
		(*Node_TaskNode)(nil),
		(*Node_WorkflowNode)(nil),
		(*Node_BranchNode)(nil),
		(*Node_ClosureNode)(nil),
	}
}

func _Node_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Node)
	// target
	switch x := m.Target.(type) {
	case *Node_TaskNode:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TaskNode); err != nil {
			return err
		}
	case *Node_WorkflowNode:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.WorkflowNode); err != nil {
			return err
		}
	case *Node_BranchNode:
		b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BranchNode); err != nil {
			return err
		}
	case *Node_ClosureNode:
		b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ClosureNode); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Node.Target has unexpected type %T", x)
	}
	return nil
}

func _Node_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Node)
	switch tag {
	case 6: // target.task_node
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TaskNode)
		err := b.DecodeMessage(msg)
		m.Target = &Node_TaskNode{msg}
		return true, err
	case 7: // target.workflow_node
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(WorkflowNode)
		err := b.DecodeMessage(msg)
		m.Target = &Node_WorkflowNode{msg}
		return true, err
	case 8: // target.branch_node
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BranchNode)
		err := b.DecodeMessage(msg)
		m.Target = &Node_BranchNode{msg}
		return true, err
	case 9: // target.closure_node
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ClosureNode)
		err := b.DecodeMessage(msg)
		m.Target = &Node_ClosureNode{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Node_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Node)
	// target
	switch x := m.Target.(type) {
	case *Node_TaskNode:
		s := proto.Size(x.TaskNode)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Node_WorkflowNode:
		s := proto.Size(x.WorkflowNode)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Node_BranchNode:
		s := proto.Size(x.BranchNode)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Node_ClosureNode:
		s := proto.Size(x.ClosureNode)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Metadata for the entire workflow.
// To be used in the future.
type WorkflowMetadata struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WorkflowMetadata) Reset()         { *m = WorkflowMetadata{} }
func (m *WorkflowMetadata) String() string { return proto.CompactTextString(m) }
func (*WorkflowMetadata) ProtoMessage()    {}
func (*WorkflowMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_literals_1ac04b6ab2b9b143, []int{23}
}
func (m *WorkflowMetadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WorkflowMetadata.Unmarshal(m, b)
}
func (m *WorkflowMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WorkflowMetadata.Marshal(b, m, deterministic)
}
func (dst *WorkflowMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowMetadata.Merge(dst, src)
}
func (m *WorkflowMetadata) XXX_Size() int {
	return xxx_messageInfo_WorkflowMetadata.Size(m)
}
func (m *WorkflowMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowMetadata proto.InternalMessageInfo

// Flyte Workflow Structure that encapsulates task, branch and subworkflow nodes to form a statically analyzable,
// directed acyclic graph.
type WorkflowTemplate struct {
	// This is an autogenerated id by the system. The id is globally unique across the system.
	Id *Identifier `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Extra metadata about the workflow.
	Metadata *WorkflowMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Defines a strongly typed interface for the Workflow. This can include some optional parameters.
	Interface *TypedInterface `protobuf:"bytes,3,opt,name=interface,proto3" json:"interface,omitempty"`
	// A list of nodes. In addition, "globals" is a special reserved node id that can be used to consume workflow inputs.
	Nodes []*Node `protobuf:"bytes,4,rep,name=nodes,proto3" json:"nodes,omitempty"`
	// A list of output bindings that specify how to construct workflow outputs. Bindings can pull node outputs or
	// specify literals. All workflow outputs specified in the interface field must be bound in order for the workflow
	// to be validated. A workflow has an implicit dependency on all of its nodes to execute successfully in order to
	// bind final outputs.
	// Most of these outputs will be Binding's with a BindingData of type OutputReference.  That is, your workflow can
	// just have an output of some constant (`Output(5)`), but usually, the workflow will be pulling
	// outputs from the output of a task.
	Outputs []*Binding `protobuf:"bytes,5,rep,name=outputs,proto3" json:"outputs,omitempty"`
	// +optional A catch-all node. This node is executed whenever the execution engine determines the workflow has failed.
	// The interface of this node must match the Workflow interface with an additional input named "error" of type
	// pb.lyft.flyte.core.Error.
	FailureNode          *Node    `protobuf:"bytes,6,opt,name=failure_node,json=failureNode,proto3" json:"failure_node,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WorkflowTemplate) Reset()         { *m = WorkflowTemplate{} }
func (m *WorkflowTemplate) String() string { return proto.CompactTextString(m) }
func (*WorkflowTemplate) ProtoMessage()    {}
func (*WorkflowTemplate) Descriptor() ([]byte, []int) {
	return fileDescriptor_literals_1ac04b6ab2b9b143, []int{24}
}
func (m *WorkflowTemplate) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WorkflowTemplate.Unmarshal(m, b)
}
func (m *WorkflowTemplate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WorkflowTemplate.Marshal(b, m, deterministic)
}
func (dst *WorkflowTemplate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowTemplate.Merge(dst, src)
}
func (m *WorkflowTemplate) XXX_Size() int {
	return xxx_messageInfo_WorkflowTemplate.Size(m)
}
func (m *WorkflowTemplate) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowTemplate.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowTemplate proto.InternalMessageInfo

func (m *WorkflowTemplate) GetId() *Identifier {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *WorkflowTemplate) GetMetadata() *WorkflowMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *WorkflowTemplate) GetInterface() *TypedInterface {
	if m != nil {
		return m.Interface
	}
	return nil
}

func (m *WorkflowTemplate) GetNodes() []*Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *WorkflowTemplate) GetOutputs() []*Binding {
	if m != nil {
		return m.Outputs
	}
	return nil
}

func (m *WorkflowTemplate) GetFailureNode() *Node {
	if m != nil {
		return m.FailureNode
	}
	return nil
}

func init() {
	proto.RegisterType((*Void)(nil), "flyteidl.core.Void")
	proto.RegisterType((*Blob)(nil), "flyteidl.core.Blob")
	proto.RegisterType((*BlobMetadata)(nil), "flyteidl.core.BlobMetadata")
	proto.RegisterType((*Binary)(nil), "flyteidl.core.Binary")
	proto.RegisterType((*Schema)(nil), "flyteidl.core.Schema")
	proto.RegisterType((*Scalar)(nil), "flyteidl.core.Scalar")
	proto.RegisterType((*Closure)(nil), "flyteidl.core.Closure")
	proto.RegisterType((*Literal)(nil), "flyteidl.core.Literal")
	proto.RegisterType((*LiteralCollection)(nil), "flyteidl.core.LiteralCollection")
	proto.RegisterType((*LiteralMap)(nil), "flyteidl.core.LiteralMap")
	proto.RegisterMapType((map[string]*Literal)(nil), "flyteidl.core.LiteralMap.LiteralsEntry")
	proto.RegisterType((*BindingDataCollection)(nil), "flyteidl.core.BindingDataCollection")
	proto.RegisterType((*BindingDataMap)(nil), "flyteidl.core.BindingDataMap")
	proto.RegisterMapType((map[string]*BindingData)(nil), "flyteidl.core.BindingDataMap.BindingsEntry")
	proto.RegisterType((*BindingData)(nil), "flyteidl.core.BindingData")
	proto.RegisterType((*Binding)(nil), "flyteidl.core.Binding")
	proto.RegisterType((*IfBlock)(nil), "flyteidl.core.IfBlock")
	proto.RegisterType((*IfElseBlock)(nil), "flyteidl.core.IfElseBlock")
	proto.RegisterType((*BranchNode)(nil), "flyteidl.core.BranchNode")
	proto.RegisterType((*ClosureNode)(nil), "flyteidl.core.ClosureNode")
	proto.RegisterType((*TaskNode)(nil), "flyteidl.core.TaskNode")
	proto.RegisterType((*WorkflowNode)(nil), "flyteidl.core.WorkflowNode")
	proto.RegisterType((*NodeMetadata)(nil), "flyteidl.core.NodeMetadata")
	proto.RegisterType((*Alias)(nil), "flyteidl.core.Alias")
	proto.RegisterType((*Node)(nil), "flyteidl.core.Node")
	proto.RegisterType((*WorkflowMetadata)(nil), "flyteidl.core.WorkflowMetadata")
	proto.RegisterType((*WorkflowTemplate)(nil), "flyteidl.core.WorkflowTemplate")
}

func init() {
	proto.RegisterFile("flyteidl/core/literals.proto", fileDescriptor_literals_1ac04b6ab2b9b143)
}

var fileDescriptor_literals_1ac04b6ab2b9b143 = []byte{
	// 1475 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x57, 0xdb, 0x8e, 0x13, 0x47,
	0x10, 0xf5, 0xfd, 0x52, 0xf6, 0x6e, 0xa0, 0x03, 0xc4, 0x38, 0x5c, 0x56, 0xa3, 0x48, 0xdc, 0x82,
	0xbd, 0x2c, 0xd1, 0x06, 0xb1, 0x09, 0x11, 0x86, 0x0d, 0x5e, 0x09, 0x42, 0xe8, 0x45, 0x41, 0xca,
	0x8b, 0xd5, 0x9e, 0x69, 0x7b, 0x5b, 0x3b, 0x9e, 0xb1, 0x7a, 0x7a, 0x20, 0x56, 0x3e, 0x22, 0x7f,
	0x91, 0x97, 0xbc, 0xf1, 0x1d, 0x79, 0xcc, 0x57, 0x44, 0x8a, 0xf2, 0x0b, 0x51, 0xdf, 0xc6, 0xe3,
	0xf1, 0x78, 0x03, 0x6f, 0xd3, 0xae, 0x53, 0xd5, 0xd5, 0x55, 0xa7, 0x2e, 0x86, 0x2b, 0x13, 0x7f,
	0x21, 0x28, 0xf3, 0xfc, 0xbe, 0x1b, 0x72, 0xda, 0xf7, 0x99, 0xa0, 0x9c, 0xf8, 0x51, 0x6f, 0xce,
	0x43, 0x11, 0xa2, 0x2d, 0x2b, 0xed, 0x49, 0x69, 0xf7, 0xda, 0x2a, 0x98, 0x79, 0x34, 0x10, 0x6c,
	0xc2, 0x28, 0xd7, 0xf0, 0xee, 0xf5, 0x69, 0x18, 0x4e, 0x7d, 0xda, 0x57, 0xa7, 0x71, 0x3c, 0xe9,
	0x0b, 0x36, 0xa3, 0x91, 0x20, 0xb3, 0xb9, 0x01, 0x5c, 0xcb, 0x02, 0xbc, 0x98, 0x13, 0xc1, 0xc2,
	0xc0, 0xc8, 0xaf, 0x64, 0xe5, 0x91, 0xe0, 0xb1, 0x2b, 0x8c, 0xf4, 0xf2, 0xea, 0xf5, 0x62, 0x31,
	0xa7, 0xc6, 0xd1, 0xee, 0xd5, 0x55, 0x91, 0x1b, 0x06, 0x1e, 0x4b, 0xd9, 0xcd, 0x6a, 0x92, 0xe8,
	0xd4, 0x6a, 0x66, 0xde, 0x34, 0xe7, 0x6c, 0xc6, 0x04, 0x7b, 0x6b, 0x2d, 0x3b, 0x35, 0xa8, 0xfc,
	0x14, 0x32, 0xcf, 0x79, 0x05, 0x95, 0x81, 0x1f, 0x8e, 0xd1, 0xd7, 0xd0, 0x98, 0x51, 0x41, 0x3c,
	0x22, 0x48, 0xa7, 0xb8, 0x53, 0xbc, 0xd9, 0xda, 0xfb, 0xbc, 0xb7, 0x12, 0xa5, 0x9e, 0x84, 0xbd,
	0x30, 0x10, 0x9c, 0x80, 0xd1, 0x39, 0x28, 0xc7, 0x9c, 0x75, 0xca, 0x3b, 0xc5, 0x9b, 0x4d, 0x2c,
	0x3f, 0x9d, 0x03, 0x68, 0xa7, 0xb1, 0xe8, 0x0e, 0x54, 0xe4, 0x9b, 0x8c, 0xd9, 0xcf, 0x72, 0xcc,
	0xbe, 0x5e, 0xcc, 0x29, 0x56, 0x20, 0x67, 0x17, 0x6a, 0x03, 0x16, 0x10, 0xbe, 0x40, 0x17, 0xa0,
	0xfa, 0x96, 0xf8, 0xb1, 0xd6, 0x6b, 0x63, 0x7d, 0x90, 0xd7, 0x09, 0x32, 0xed, 0x94, 0xf4, 0x75,
	0x82, 0x4c, 0x9d, 0x23, 0xa8, 0x1d, 0xbb, 0x27, 0x74, 0x96, 0xb8, 0x52, 0x4c, 0x5c, 0x41, 0x77,
	0xcd, 0xd5, 0x65, 0x75, 0xf5, 0xe5, 0xcc, 0xd5, 0x5a, 0x2d, 0x75, 0xf9, 0xbf, 0x25, 0x69, 0x8b,
	0xf8, 0x84, 0xa3, 0x07, 0xd0, 0x4c, 0x62, 0x66, 0x3c, 0xef, 0x64, 0xd4, 0x7f, 0xb4, 0xf2, 0x61,
	0x01, 0x2f, 0xc1, 0xe8, 0x16, 0x54, 0xc6, 0x7e, 0x38, 0x56, 0x2e, 0xb6, 0xf6, 0x3e, 0xcd, 0x79,
	0xee, 0xb0, 0x80, 0x15, 0x04, 0xf5, 0xa1, 0x36, 0x56, 0x8f, 0x35, 0x0e, 0x5e, 0xcc, 0x82, 0x95,
	0x70, 0x58, 0xc0, 0x06, 0x26, 0x15, 0x22, 0xe5, 0x74, 0xa7, 0x92, 0xab, 0xa0, 0x5f, 0x24, 0x15,
	0x34, 0x0c, 0xed, 0x41, 0x33, 0x08, 0x03, 0x3a, 0x52, 0x51, 0xa8, 0xe6, 0x7a, 0x24, 0x69, 0x30,
	0x2c, 0xe0, 0x86, 0xc4, 0xc9, 0x58, 0xa0, 0x2f, 0xa1, 0x4a, 0x39, 0x0f, 0x79, 0xa7, 0xa6, 0xf0,
	0x17, 0x32, 0xf8, 0x43, 0x29, 0x1b, 0x16, 0xb0, 0x06, 0xa1, 0xfb, 0x50, 0x9f, 0xd2, 0x80, 0x72,
	0xe6, 0x76, 0xea, 0x26, 0xc1, 0x9a, 0xed, 0x3d, 0xcb, 0xf6, 0xde, 0xb1, 0x62, 0xfb, 0xb0, 0x80,
	0x2d, 0x72, 0x50, 0x37, 0xb9, 0x75, 0xfe, 0x28, 0x42, 0xfd, 0x89, 0x1f, 0x46, 0x31, 0xa7, 0xe8,
	0x06, 0x54, 0x82, 0xd0, 0xb3, 0xd1, 0xce, 0xba, 0xf9, 0x43, 0xe8, 0x51, 0xac, 0x00, 0xe8, 0x1e,
	0x54, 0x15, 0xd5, 0x3b, 0xa5, 0x9d, 0x72, 0x0e, 0x51, 0x5f, 0x93, 0xe8, 0xf4, 0x35, 0x9d, 0xcd,
	0x7d, 0x22, 0x28, 0xd6, 0x48, 0xf4, 0x14, 0xb6, 0xa2, 0x78, 0x3c, 0x7a, 0x17, 0xf2, 0xd3, 0x89,
	0x1f, 0xbe, 0x8b, 0x3a, 0x65, 0xa5, 0x7a, 0x3d, 0xa3, 0xfa, 0xc6, 0xc8, 0x13, 0xf5, 0x76, 0x14,
	0x8f, 0xed, 0x8f, 0x91, 0xf3, 0x77, 0x11, 0xea, 0xcf, 0x75, 0x2b, 0xd1, 0xa9, 0x90, 0x54, 0x31,
	0xfe, 0xae, 0xa7, 0x42, 0x0a, 0x75, 0x2a, 0x14, 0xa3, 0x06, 0x00, 0x6e, 0xe8, 0xfb, 0xd4, 0x95,
	0x05, 0x6c, 0xd8, 0xb1, 0x93, 0x51, 0x32, 0xc6, 0x9f, 0x24, 0xb8, 0x61, 0x01, 0xa7, 0xb4, 0xd0,
	0x5d, 0x28, 0xcf, 0xc8, 0x7c, 0x03, 0x9d, 0x8d, 0xf2, 0x0b, 0x32, 0x1f, 0x16, 0xb0, 0xc4, 0xa1,
	0x3d, 0xa8, 0xbb, 0x3a, 0xb8, 0x86, 0x2f, 0x97, 0x32, 0x2a, 0x26, 0xf4, 0x32, 0x35, 0x06, 0xb8,
	0x4c, 0xcd, 0x33, 0x38, 0xbf, 0xe6, 0x0e, 0xda, 0x83, 0x86, 0xed, 0xa5, 0x9d, 0xa2, 0x0a, 0xe1,
	0xa5, 0x7c, 0x2f, 0x70, 0x82, 0x73, 0x7e, 0x2f, 0x02, 0x2c, 0x7d, 0x43, 0x4f, 0xd6, 0x4c, 0xdc,
	0xd8, 0xf8, 0x10, 0xfb, 0x19, 0x1d, 0x06, 0x82, 0x2f, 0x96, 0x36, 0xbb, 0xc7, 0xb0, 0xb5, 0x22,
	0x92, 0xb5, 0x7f, 0x4a, 0x17, 0xb6, 0xf6, 0x4f, 0xe9, 0x42, 0xd2, 0x58, 0xf7, 0x8f, 0x52, 0xee,
	0xd3, 0xad, 0x9f, 0x1a, 0xf4, 0xb0, 0xf4, 0xa0, 0xe8, 0xbc, 0x84, 0x8b, 0x03, 0x16, 0x78, 0x2c,
	0x98, 0x3e, 0x25, 0x82, 0xa4, 0x5e, 0xbd, 0x0f, 0x8d, 0xb1, 0x16, 0x58, 0x97, 0xbb, 0xeb, 0x95,
	0x6a, 0xf5, 0x70, 0x82, 0x75, 0xde, 0x17, 0x61, 0x3b, 0x25, 0x91, 0xaf, 0x7f, 0xb6, 0x66, 0xea,
	0xce, 0x66, 0x53, 0x32, 0x02, 0xe6, 0x68, 0x23, 0x60, 0x95, 0xbb, 0x6f, 0x60, 0x6b, 0x45, 0x94,
	0x13, 0x81, 0xdd, 0xd5, 0x08, 0x9c, 0xe5, 0x73, 0x2a, 0x0a, 0xef, 0x4b, 0xd0, 0x4a, 0x89, 0x3e,
	0x9e, 0xe8, 0xdf, 0xe7, 0x10, 0xfd, 0x8b, 0xcd, 0x77, 0x6f, 0x24, 0xfb, 0x43, 0xa8, 0xcf, 0x79,
	0x38, 0x63, 0x91, 0xed, 0xdf, 0xd7, 0x32, 0x46, 0x5e, 0xc6, 0x62, 0x1e, 0x0b, 0x4c, 0x27, 0x94,
	0xd3, 0xc0, 0x55, 0x2c, 0x36, 0x0a, 0xe8, 0x9e, 0x2e, 0x14, 0xcd, 0xfa, 0xab, 0x67, 0x46, 0x38,
	0xa7, 0x58, 0xaa, 0x1f, 0x5d, 0x2c, 0xaf, 0xa0, 0x6e, 0xac, 0xca, 0x3c, 0xbc, 0x35, 0xc1, 0x6a,
	0x62, 0xf9, 0x89, 0xbe, 0x82, 0xba, 0x49, 0xdb, 0x07, 0x64, 0xc2, 0x42, 0x9d, 0x5f, 0xa1, 0x7e,
	0x34, 0x19, 0xf8, 0xa1, 0x7b, 0x8a, 0x1e, 0x41, 0x33, 0x19, 0xfd, 0x26, 0x0b, 0xd9, 0xce, 0x31,
	0x08, 0x43, 0x9f, 0x92, 0xe0, 0xf0, 0x97, 0x39, 0xa7, 0x51, 0xc4, 0xc2, 0x00, 0x2f, 0x55, 0xd0,
	0x2e, 0x34, 0xc5, 0x09, 0x0d, 0x46, 0xaa, 0xbd, 0x96, 0x36, 0xb7, 0xd7, 0x86, 0x44, 0xc9, 0x2f,
	0xe7, 0xaf, 0x22, 0xb4, 0x8e, 0x26, 0x87, 0x7e, 0x44, 0xb5, 0x07, 0xb7, 0xa1, 0xe2, 0x92, 0xc8,
	0xf6, 0xe6, 0x6c, 0x64, 0x8c, 0x9f, 0x58, 0x61, 0x64, 0xe1, 0x85, 0xe2, 0x84, 0x72, 0xd3, 0x9e,
	0x37, 0x81, 0x35, 0x48, 0x4e, 0x28, 0xea, 0x47, 0x54, 0xfb, 0x56, 0xde, 0xe8, 0x9b, 0x9c, 0x50,
	0x12, 0x27, 0xbf, 0x97, 0x13, 0xaa, 0xf2, 0x01, 0x13, 0x6a, 0xd0, 0x84, 0xba, 0x47, 0x27, 0x24,
	0xf6, 0x85, 0xf3, 0x18, 0x60, 0xc0, 0x49, 0xe0, 0x9e, 0x28, 0x33, 0xf7, 0xa1, 0xce, 0x26, 0x23,
	0x69, 0xd5, 0xbc, 0xab, 0xbb, 0xe6, 0x6a, 0x12, 0x01, 0x5c, 0x63, 0xea, 0xe0, 0x3c, 0x87, 0x96,
	0x21, 0x82, 0xb2, 0xf1, 0x2d, 0xb4, 0x0d, 0x19, 0x46, 0xa9, 0x25, 0xa7, 0x9b, 0x4f, 0x1d, 0xb5,
	0x6a, 0xb4, 0xdc, 0xe5, 0xc1, 0x79, 0x03, 0x0d, 0x39, 0xae, 0x94, 0xa9, 0x47, 0xd0, 0xe6, 0x96,
	0xcb, 0x23, 0xe6, 0x19, 0x53, 0xd9, 0x2e, 0x7f, 0x94, 0x6c, 0xa7, 0xc3, 0x02, 0x6e, 0x25, 0x0a,
	0x47, 0xde, 0xa0, 0x05, 0xcd, 0xe4, 0x28, 0x9b, 0x6e, 0xdb, 0x0e, 0x2e, 0x65, 0x7d, 0x00, 0xdb,
	0x3e, 0x89, 0x03, 0xf7, 0x64, 0xee, 0x93, 0x60, 0xc4, 0xe9, 0xe4, 0x43, 0xec, 0x6f, 0x2d, 0x55,
	0x30, 0x9d, 0xa0, 0x43, 0x38, 0x97, 0x9e, 0xa2, 0xca, 0x4a, 0xe9, 0xff, 0xad, 0x6c, 0xa7, 0x86,
	0x28, 0xa6, 0x93, 0x55, 0x47, 0x7f, 0x2b, 0x42, 0x5b, 0x3a, 0x98, 0xac, 0x8b, 0x08, 0x2a, 0x01,
	0x99, 0x51, 0x53, 0x40, 0xea, 0x5b, 0x66, 0x4a, 0xee, 0xdc, 0x61, 0x2c, 0x4c, 0xca, 0x2f, 0xaf,
	0x2d, 0x19, 0x4f, 0xcd, 0xca, 0x8d, 0x2d, 0x12, 0xed, 0x43, 0x9d, 0x53, 0xc1, 0x19, 0x8d, 0x4c,
	0x41, 0x5f, 0xc9, 0x38, 0x89, 0xa9, 0xe0, 0x8b, 0x63, 0xc1, 0x89, 0xa0, 0xd3, 0x05, 0xb6, 0x60,
	0xa7, 0x0f, 0xd5, 0xc7, 0x3e, 0x23, 0x51, 0x4e, 0x25, 0x5f, 0x80, 0x2a, 0x91, 0x22, 0xb3, 0x7f,
	0xea, 0x83, 0xf3, 0x4f, 0x19, 0x2a, 0x2a, 0xc6, 0xdb, 0x50, 0x32, 0x79, 0x6b, 0xe2, 0x12, 0xf3,
	0x56, 0x96, 0xea, 0x52, 0xee, 0x52, 0x9d, 0x7e, 0x79, 0x6a, 0xa9, 0xee, 0x41, 0x8d, 0x05, 0xf3,
	0x58, 0xd8, 0x3d, 0xe5, 0x52, 0x7e, 0xc3, 0xc0, 0x06, 0x85, 0x6e, 0xc3, 0xf9, 0x78, 0x1e, 0x09,
	0x4e, 0xc9, 0x4c, 0x15, 0xd2, 0x88, 0x79, 0x51, 0xa7, 0xb2, 0x53, 0xbe, 0xd9, 0xc4, 0x9f, 0x58,
	0x81, 0xbc, 0xea, 0xc8, 0x8b, 0xd0, 0x01, 0x6c, 0x87, 0xaa, 0x71, 0x8e, 0x94, 0xf7, 0x2a, 0x3a,
	0xe5, 0x9c, 0x2a, 0x52, 0x31, 0xc0, 0x5b, 0x1a, 0xfb, 0x58, 0x43, 0xd1, 0x3e, 0x34, 0xe5, 0x42,
	0xa5, 0xab, 0xb5, 0x96, 0xbb, 0xd0, 0x5b, 0x3e, 0xcb, 0x8a, 0x15, 0x96, 0xdb, 0x03, 0xd8, 0x4a,
	0x58, 0xa3, 0x74, 0xeb, 0xb9, 0xe1, 0x48, 0x33, 0x76, 0x58, 0xc0, 0xed, 0x77, 0x69, 0x06, 0x7f,
	0x03, 0xad, 0xb1, 0x2a, 0x5e, 0x6d, 0xa1, 0x91, 0x4b, 0xbc, 0x65, 0x79, 0xcb, 0x69, 0x32, 0x5e,
	0x16, 0xfb, 0x77, 0xcb, 0x42, 0x55, 0xea, 0xcd, 0xb3, 0x0a, 0xd5, 0xe8, 0xdb, 0x52, 0x95, 0xc7,
	0x41, 0x03, 0x6a, 0x82, 0xf0, 0x29, 0x15, 0x0e, 0x82, 0x73, 0xd6, 0x51, 0x9b, 0x3b, 0xe7, 0xcf,
	0xd2, 0xf2, 0x47, 0xbb, 0x3d, 0xa2, 0x5b, 0x09, 0x1f, 0xce, 0xaa, 0x10, 0x45, 0x95, 0x83, 0x35,
	0xaa, 0x6c, 0xda, 0x4d, 0x73, 0xe8, 0x72, 0x00, 0x4d, 0x16, 0x08, 0xca, 0x27, 0xc4, 0xb5, 0x3d,
	0x34, 0x3b, 0xf3, 0x64, 0xb7, 0xf1, 0x8e, 0x2c, 0x08, 0x2f, 0xf1, 0xe8, 0x16, 0x54, 0x65, 0x40,
	0x34, 0x5f, 0x36, 0x0c, 0x06, 0x8d, 0x40, 0xbb, 0x50, 0xd7, 0x74, 0xb0, 0x9c, 0xd9, 0xc4, 0x4b,
	0x0b, 0x43, 0xfb, 0xd0, 0x9e, 0x10, 0xe6, 0x27, 0x51, 0xaf, 0x6d, 0x1e, 0x3e, 0x2d, 0x03, 0x54,
	0xc1, 0xde, 0xfb, 0x79, 0x77, 0xca, 0xc4, 0x49, 0x3c, 0xee, 0xb9, 0xe1, 0xac, 0xef, 0x2f, 0x26,
	0xa2, 0x9f, 0xfc, 0xa1, 0x9d, 0xd2, 0xa0, 0x3f, 0x1f, 0xdf, 0x9d, 0x86, 0xfd, 0x95, 0xff, 0xb8,
	0xe3, 0x9a, 0xea, 0x05, 0xf7, 0xff, 0x0b, 0x00, 0x00, 0xff, 0xff, 0x99, 0xff, 0x06, 0x34, 0xfc,
	0x0f, 0x00, 0x00,
}
